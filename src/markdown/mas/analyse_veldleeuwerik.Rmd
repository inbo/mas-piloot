---
title: "Distance sampling Veldleeuwerik"
author: "Ward Langeraert"
date: "`r Sys.Date()`"

output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
    
editor_options: 
  chunk_output_type: console
  
bibliography: [references.json, packages.bib]
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/research-institute-for-nature-and-forest.csl
zotero: true
---

```{r setup, include=FALSE}
renv::restore()

# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE)
opts_knit$set(root.dir = here::here())

# Data preparation and visualization
library(tidyverse)
library(INBOtheme)

library(targets)
library(sf)
library(terra)
library(lubridate)
library(gridExtra)

# Data analysis
library(Distance)

# Source
targets_store <- here("src", "targets", "mas_steekproef_pilootfase", "_targets")
mbag_dir <- here()
source(here("src", "R", "wfs_wcs.R"))
source(here("src", "R", "berekening_hulpvariabelen.R"))
source(here("src", "R", "sim.pdata.R"))
source(here("src", "R", "plot_detection_curve.R"))
source(here("src", "R", "summarize_ds_models2.R"))
```

```{r}
knitr::write_bib(c("base", "Distance"), here("src", "markdown", "mas", 
                                             "packages.bib"))
```

# Doel {#doel}

Een robuuste en reproduceerbare workflow creëren om de densiteit van akkervogels te schatten rekening houdend met de detectiekans.
Omwille van het verschil in design tussen 2022 en de voorgaande jaren, zullen we densiteiten schatten voor twee datasets:

1.  2018-2022: 
    -   schatting per stratum: jaar, regio
    -   zou allemaal (grotendeels) OL en binnen sbp moeten zijn
    -   voeg enkel plots van 2022 toe als ze minstens eenmaal geteld zijn in een van de voorgaande jaren
2.  2022
    -   schatting per stratum: regio, sbp, openheid
    -   volledige dataset 2022

# Inlezen data {#inlezen-data}

We selecteren eerst de MAS-data binnen de telrondes.

```{r ronde-intervallen}
r1_start <- "04-01"
r1_stop <- "04-20"
r2_start <- "04-21"
r2_stop <- "05-10"
r3_start <- "05-11"
r3_stop <- "06-10"
r4_start <- "06-21"
r4_stop <- "07-15"
```

```{r inlezen-mas-waarnemingen-2018-2022}
mas <- read_sf(
  here("data/mas/20220906_qgis_export_sovon_wfs.gpkg")) %>%
  mutate(
    datum = ymd(paste(jaar, maand, dag, sep = "-")),
    periode_in_jaar = case_when(
      datum %within% interval(
        ymd(paste(jaar, r1_start, sep = "-")),
        ymd(paste(jaar, r1_stop, sep = "-"))) ~ "R1",
      datum %within% interval(
        ymd(paste(jaar, r2_start, sep = "-")),
        ymd(paste(jaar, r2_stop, sep = "-"))) ~ "R2",
      datum %within% interval(
        ymd(paste(jaar, r3_start, sep = "-")),
        ymd(paste(jaar, r3_stop, sep = "-"))) ~ "R3",
      datum %within% interval(
        ymd(paste(jaar, r4_start, sep = "-")),
        ymd(paste(jaar, r4_stop, sep = "-"))) ~ "R4"
    ))
```

De CRS moet aangepast worden naar Lambert 72.
Dit doen we via een specifieke pipeline, zie: <https://inbo.github.io/tutorials/tutorials/spatial_transform_crs_2/>

```{r mas-waarnemingen-conversie-31370}
Sys.setenv("PROJ_NETWORK" = "ON")
sf_proj_network(TRUE)
pipelines <- sf_proj_pipelines("EPSG:28992", "EPSG:31370")
glimpse(pipelines)
# We select the pipeline with lowest accuracy (< 0.02), by filtering on accuracy.
# If the grids are installed, this should match the first line of the pipelines object.
chosen_pipeline_definition <- pipelines %>%
  filter(accuracy < 0.02) %>% pull(definition)

mas_31370_pipeline1 <- 
  st_transform(st_geometry(mas), "EPSG:31370",
               pipeline = chosen_pipeline_definition) %>% 
  st_sf(st_drop_geometry(mas), geometry = .) %>% 
  as_tibble %>% 
  st_as_sf
```

```{r inlezen-polygoon-lagen}
perimeters <- read_sf(
  here("data", "processed", "piloot_perimeters.gpkg"))

vlaanderen <- get_feature_wfs(
  wfs = "https://eservices.minfin.fgov.be/arcgis/services/R2C/Regions/MapServer/WFSServer",
  layername = "regions",
  crs = "EPSG:31370",
  filter = "<Filter><PropertyIsEqualTo><PropertyName>regions:NameDUT</PropertyName><Literal>'Vlaams Gewest'</Literal></PropertyIsEqualTo></Filter>") %>%
  select(NameDUT)

sbp_akkervogels <- tar_read(sbp_akkervogels,
                            store = targets_store)

```

We bepalen alle plot-jaar combinaties waarvoor er waarnemingen zijn.
Het kan ook zijn dat een plot bezocht is, maar dat er geen waarnemingen van zijn.

```{r plot-jaar-waarnemingen-2018-2022}
plot_jaar_met_waarnemingen <- mas_31370_pipeline1 %>%
  st_drop_geometry() %>%
  distinct(plotnaam, jaar)
```

Voor 2022 kennen we alle telpunten die geteld/bezocht moesten worden.
Voor 2018-2021 moeten we er *voorlopig* vanuit gaan dat als er geen waarnemingen zijn voor een bepaald telpunt, het telpunt niet geteld werd.

<!--De plot-jaar lijsten voor 2018-2021 opvragen die bezocht werden zodat we nullen/afwezigheden correct kunnen toevoegen-->

We stellen nu eerst een lijst samen van plot - jaar combinaties die bezocht zijn.
Hiervoor moeten we eerst het design inlezen van 2022.

```{r design_2022}
design2022_raw <- read_csv(here(
    "data",
    "processed",
    "steekproef_piloot_avimap.csv")) %>%
  select(plotnaam = definitief_punt,
         regio,
         stratum,
         X, Y) %>%
  mutate(openheid = ifelse(grepl("HOL", stratum), "HOL", "OL"),
         sbp = ifelse(grepl("binnen", stratum), "binnen", "buiten"),
         stratum = gsub("L\\s{1}", "L\\\n", stratum),
         jaar = 2022L) %>%
  st_as_sf(coords = c("X", "Y"), crs = 31370)

plot_bezocht_2022 <- design2022_raw %>%
  st_drop_geometry() %>%
  distinct(plotnaam, jaar)
```

Vervolgens samenvoegen met 2018-2021

```{r plot-jaar-bezocht-2018-2022}
# veronderstel dat bezocht gelijk is aan die met waarnemingen voor 2018-2021
plot_jaar_bezocht <- plot_jaar_met_waarnemingen %>%
  filter(jaar < 2022) %>%
  rbind(plot_bezocht_2022)
```

Zijn er bezochte plots waarvan er geen waarnemingen zijn?

```{r bezocht-zonder-waarnemingen}
pjb <- plot_jaar_bezocht %>%
  anti_join(plot_jaar_met_waarnemingen)

pjb %>%
  kable()
```

Ja, in `r nrow(pjb)` telpunten werd niets waargenomen.
Dus het is aannemelijk dat dit ook in de eerdere jaren soms het geval zal geweest zijn.

We voegen nu eerst de locatie van de telpunten toe aan `plot_jaar_bezocht`.
De dataframe `telpunten_2018_2021` bevat alle MAS telpunten die in de periode 2018-2021 zijn doorgegeven aan SOVON.
Het is echter niet zo dat al deze telpunten in elk jaar geteld zijn.
Het kan zelfs zijn dat een telpunt uit deze lijst in geen enkel jaar werd geteld (= helemaal niet bezocht geweest).
Het kan ook zijn dat het wel bezocht is geweest, maar dat er geen waarnemingen zijn.

```{r telpunten-2018-2021}
telpunten_2018_2021 <- read_sf(
  here("data", "mas",
       "avimap_514_0_MAS_Werkgroep_Grauwe_Kiekendief_Belgi__telpunten_xy.shp")
) %>%
  rename(teller_2021 = teller) %>%
  mutate(
    regio = ifelse(is.na(regio), "Vlaanderen - Bilzen", regio),
    type_teller_2021 = case_when(
      teller_2021 %in% c("WVNT00", "JJNN16", "NOVN00") |
        regio == "Vlaanderen - Leefdaal" ~ "professioneel",
      is.na(teller_2021) &
        regio != "Vlaanderen - Leefdaal" ~ "niet geteld in 2021",
      TRUE ~ "vrijwilliger"))

telpunten_2018_2021_amersfoort <- telpunten_2018_2021 %>%
  st_drop_geometry() %>%
  st_as_sf(coords = c("st_x", "st_y"), crs = 28992)

telpunten_2018_2021 <- st_transform(
  st_geometry(telpunten_2018_2021_amersfoort), "EPSG:31370",
  pipeline = chosen_pipeline_definition) %>% 
  st_sf(st_drop_geometry(telpunten_2018_2021), geometry = .) %>% 
  as_tibble %>% 
  st_as_sf %>%
  mutate(regio = gsub("Vlaanderen - ", "", regio),
         regio = ifelse(regio == "Leemstreek", "Oostelijke leemstreek", regio),
         regio = ifelse(regio == "Bilzen", "Oostelijke leemstreek", regio))
```

```{r telpunten-2018-2022-locaties}
telpunten_2018_2021_geom_only <- telpunten_2018_2021 %>%
  select(plotnaam = naam, regio)

telpunten_2022_geom_only <- design2022_raw %>%
  select(plotnaam, regio)

# locaties 2022 zijn verkeerd in design_2022 voor VL plots
telpunten_geom_only <- bind_rows(
  telpunten_2018_2021_geom_only,
  telpunten_2022_geom_only %>% filter(!grepl("VL", .$plotnaam))
)
```

Nu voegen we de geometry toe aan de plot - jaar combinaties via een inner join.
Opgepast!
Er zijn een aantal telpunten die in geen enkel jaar werden bezocht.
Deze worden in deze stap verwijderd.
Het kan ook zijn dat er hier een aantal onterecht verwijderd worden (wel bezocht, maar geen waarnemingen).
Zoals eerder aangegeven in commentaar moeten we dit navragen.

```{r toevoegen-geoms}
plot_jaar_bezocht_sf <- telpunten_geom_only %>%
  inner_join(plot_jaar_bezocht)
```

Tot slot voegen we aan `plot_jaar_bezocht_sf` de strata toe waartoe ze behoren.
We gebruiken hiervoor dezelfde code als werd gebruikt in het `targets` project voor het trekken van de pilootsteekproef 2022.

```{r toevoegen-strata}
telpunten_strata <- add_openheid_landschap_to_frame(
  path = path_to_openheid_landschap(),
  punten_sf = plot_jaar_bezocht_sf %>% distinct(plotnaam, regio, geometry),
  gebied = vlaanderen,
  cutlevels = c(1.25, 1.35, 1.51),
  class_labels = c("GL", "HGL", "HOL", "OL")) %>%
  select(plotnaam, regio, openheid = openheid_klasse) %>%
  mutate(sbp = st_intersects(.,
                             st_union(sbp_akkervogels),
                             sparse = FALSE) %>%
           as.logical(),
         sbp = ifelse(sbp, "binnen", "buiten")
  ) %>%
  mutate(stratum = paste0(openheid, "\n", sbp, " plan"))

design_2018_2022_sf <- plot_jaar_bezocht_sf %>%
  st_join(telpunten_strata %>% select(-plotnaam, -regio)) %>%
  filter(regio %in% c("Oostelijke leemstreek", "De Moeren")) %>%
  mutate(openheid = as.character(openheid))
```

Voor de waarnemingen verwijderen we ook dubbeltellingen.
Indien de soort gezien was op meerdere teldagen binnen eenzelfde telperiode, wordt de laatste teldag genomen.

```{r check-dubbeltelling}
dubbels <- mas_31370_pipeline1 %>%
  st_drop_geometry() %>%
  group_by(plotid, jaar, periode_in_jaar, soortnr) %>%
  summarize(aantal_teldagen = n_distinct(doy),
            .groups = "drop") %>%
  filter(aantal_teldagen > 1)
# kan zowel zelfde waarnemer als andere waarnemer zijn

mas_clean <- mas_31370_pipeline1 %>%
  semi_join(dubbels, by = c("plotid", "jaar", "periode_in_jaar")) %>%
  group_by(plotid, jaar, periode_in_jaar) %>%
  filter(doy == max(doy)) %>%
  ungroup() %>%
  bind_rows(mas_31370_pipeline1 %>%
              anti_join(dubbels, by = c("plotid", "jaar", "periode_in_jaar")))
```

# Data selectie en preparatie {#selectie-prep-data}

## Data selectie {#selectie-data}

We zijn geïnteresseerd in broedparen van de Veldleeuwerik in De Moeren en de Oostelijke leemstreek.
Daarvoor selecteren we alleen waarnemingen met broedcode 1 of hoger.
In het Nederlandse onderzoek van @wiersma2021 beschouwen ze tevens enkel waarnemingen van binnen soortspecifieke datumgrenzen om niet-broedende individuen uit te sluiten.
Deze data hebben wij voorlopig niet (wel aanwezig op de [SOVON website](https://sovon.nl/)).
Wel selecteren we enkel waarnemingen binnen de telrondes van vogels die tot op maximum 300 m afstand van het telpunt zijn gezien.

```{r}
# design 2018-2022 Oostelijke leemstreek en De Moeren
design_2018_2022 <- design_2018_2022_sf %>%
  st_drop_geometry()

# Selecteer tellingen van Veldleeuwerik in 2018-2022 in de twee regio's
# met broedcode > 0, op minder dan 300 m en binnen telrondes
veldleeuwerik_presences <- mas_clean %>%
  filter(naam == "Veldleeuwerik", !is.na(periode_in_jaar), wrntype > 0L,
         distance2plot <= 300) %>%  
  inner_join(design_2018_2022, by = c("plotnaam", "jaar")) %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - "))
```

In telperiodes 1-3 is het aantal waarnemingen van Veldleeuwerik ongeveer even groot.
In telperiode 4 ligt dit iets lager.
We zien inderdaad op de website van SOVON dat de datumgrenzen 1 april tot 15 juni gelden [@veldleeuwerikSovon]. We nemen telperiode 4 dus niet mee in de analyses.

```{r}
veldleeuwerik_presences %>%
  ggplot() + 
  geom_bar(aes(x = periode_in_jaar, fill = factor(jaar))) +
  labs(y = "Aantal waarnemingen van Veldleeuwerik", x = "Telperiode",
       fill = "jaar") +
  facet_wrap(~regio, scales = "free_y") +
  theme(legend.position = "bottom")
```

```{r}
veldleeuwerik_presences <- veldleeuwerik_presences %>%
  filter(periode_in_jaar != "R4")
```

Slechts één plot bevind zich in half-gesloten landschap en in De Moeren maar 2 in half-open landschap.
We verwijderen deze plots voor verdere analyses.

```{r}
# Totale lijst van bezochte plots in 2018-2022
bezoekenlijst_2018_2022 <- design_2018_2022 %>% 
  expand_grid(distinct(mas_clean, periode_in_jaar)) %>% # voeg telperiodes toe
  filter(!is.na(periode_in_jaar),
         periode_in_jaar != "R4") %>%
  arrange(plotnaam, jaar, periode_in_jaar)

design <- bezoekenlijst_2018_2022 %>%
  expand(regio, openheid)
  
bezoekenlijst_2018_2022 %>%
  select(-c(jaar, periode_in_jaar)) %>%
  distinct() %>%
  group_by(regio, openheid) %>%
  summarise(aantal_plots = n()) %>%
  full_join(design, by = c("regio", "openheid")) %>%
  replace(is.na(.), 0) %>%
  arrange(regio, openheid) %>%
  kable()

# Verwijder plots
plot_to_remove <- bezoekenlijst_2018_2022 %>%
  filter(openheid == "HGL" |
         (regio == "De Moeren" & openheid == "HOL")) %>%
  pull(plotnaam) %>%
  unique()

bezoekenlijst_2018_2022 <- bezoekenlijst_2018_2022 %>%
  filter(!plotnaam %in% plot_to_remove)

veldleeuwerik_presences <- veldleeuwerik_presences %>%
  filter(!plotnaam %in% plot_to_remove)
```

Controle:

```{r}
bezoekenlijst_2018_2022 %>%
  select(-c(jaar, periode_in_jaar)) %>%
  distinct() %>%
  group_by(regio, openheid) %>%
  summarise(aantal_plots = n()) %>%
  full_join(design, by = c("regio", "openheid")) %>%
  replace(is.na(.), 0) %>%
  arrange(regio, openheid) %>%
  kable()
```

## Data preparatie {#preparatie-data}

We maken een tweede dataset waarbij we ook afwezigheden toevoegen door te joinen met de lijst van alle bezochte plots voor elke telperiode.

```{r}
# Voeg afwezigheden toe door te mergen met alle bezoeken
veldleeuwerik_df <- veldleeuwerik_presences %>%
  st_drop_geometry() %>%
  group_by(plotnaam, jaar, periode_in_jaar) %>%
  summarise(aantal = sum(aantal)) %>% # som aantallen gespot per dag 
  full_join(bezoekenlijst_2018_2022, by = c("plotnaam", "jaar", 
                                            "periode_in_jaar")) %>%
  replace(is.na(.), 0) %>%
  arrange(plotnaam, jaar, periode_in_jaar) %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - "))
```

# Data exploratie {#exploratie-data}

## Tellingen {#exploratie-tellingen}

We beschouwen data van De Moeren en de Oostelijke leemstreek van 2018-2022 waarbij er in elk jaar `r length(unique(veldleeuwerik_presences$periode_in_jaar))` telperiodes waren.
Het aantal bezochte plots neemt over het algemeen toe over de jaren, behalve in De Moeren tussen 2019 en 2020.
Het aantal waarnemingen niet altijd toe met het aantal bezochte plots.
Het aantal waargenomen broedparen is steeds gelijkaardig aan het aantal waarnemingen wat wil zeggen dat de meeste waarnemingen meestal om een enkel broedpaar (of een individu dat broedgedrag vertoont) gaat.

```{r}
plots_per_jaar <- bezoekenlijst_2018_2022 %>%
  group_by(regio, jaar) %>%
  summarise(aantal_plots = n_distinct(plotnaam))

telperiodes_per_jaar <- bezoekenlijst_2018_2022 %>%
  group_by(regio, jaar) %>%
  summarise(aantal_telperiodes = n_distinct(periode_in_jaar))

aantal_tabel <- veldleeuwerik_presences %>%
  st_drop_geometry() %>%
  group_by(regio, jaar) %>%
  summarise(aantal_waarnemingen = n(), 
            aantal_broedparen = sum(aantal),
            .groups = "drop") %>%
  full_join(plots_per_jaar, by = c("regio", "jaar")) %>%
  full_join(telperiodes_per_jaar, by = c("regio", "jaar")) %>%
  select(regio, jaar, aantal_telperiodes, aantal_plots, aantal_waarnemingen,
         aantal_broedparen) 

aantal_tabel %>%
  kable()
```

```{r}
aantal_tabel %>%
  ggplot(aes(x = aantal_plots, y = aantal_waarnemingen)) +
    geom_line() +
    geom_label(aes(label = jaar), vjust = "inward", hjust = "inward",
               alpha = 0.5) +
    labs(x = "Aantal plots", y = "Aantal waarnemingen") +
    facet_wrap(~regio, scales = "free")
```

## Aantallen {#exploratie-aantallen}

Wanneer we naar de aantallen kijken, zien we veel afwezigheden in de dataset.
Vooral in De Moeren, minder in de Oostelijke leemstreek behalve voor 2022.

```{r}
veldleeuwerik_df %>%
  group_by(regio, jaar, periode_in_jaar) %>%
  summarise(min = min(aantal), 
            mediaan = median(aantal),
            gemiddelde = mean(aantal),
            max = max(aantal),
            varantie = var(aantal)) %>%
  kable()
```

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
veldleeuwerik_df %>%
  group_by(regio, jaar, periode_in_jaar, aantal) %>%
  summarise(n = n(), .groups = "drop_last") %>%
  ggplot(aes(x = factor(aantal), y = n, fill = periode_in_jaar)) +
    geom_bar(stat = "identity") +
    theme(panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank()) + 
    facet_wrap(jaar~regio, scales = "free") +
    labs(y = "", x = "Aantal broedparen Veldleeuwerik per plot",
         fill = "telperiode") +
    theme(legend.position = c(1, 0),
          legend.justification = c(1, 0),
          legend.direction = "horizontal")
```

De volgende figuur toont het aantal getelde broedparen Veldleeuwerik per telcirkel met aanduiding van gemiddelde en 95% bootstrap betrouwbaarheidsinterval.
Vooral in De Moeren zien we variatie in het gemiddelde aantal broedparen over de telperiodes.
Zowel in De Moeren als in de Oostelijke leemstreek lijkt het gemiddelde min of meer constant over de jaren met een daling in 2022.

```{r}
veldleeuwerik_df %>%
  ggplot(aes(x = jaar, y = aantal, colour = periode_in_jaar)) +
  stat_sum(position = position_dodge(width = 0.5), alpha = 0.5) +
  stat_summary(fun.data = mean_cl_boot,
               position = position_dodge(width = 0.5),
               fatten = 4, shape = "square") +
  facet_wrap(~regio, scales = "free_y") +
  labs(y = "Aantal broedparen Veldleeuwerik per plot", x = "Jaar",
       colour = "telperiode") +
  theme(legend.position = "bottom")
```

Deze daling heeft te maken met een aanpassing van het design in 2022 waarbij veel meer plots in controlegebieden (buiten sbp) zijn toegevoegd (zie verder).

```{r}
veldleeuwerik_df %>%
  ggplot(aes(x = jaar, y = aantal, colour = periode_in_jaar)) +
  stat_sum(position = position_dodge(width = 0.5), alpha = 0.5) +
  stat_summary(fun.data = mean_cl_boot,
               position = position_dodge(width = 0.5),
               fatten = 4, shape = "square") +
  facet_wrap(~regio+sbp, scales = "free_y") +
  labs(y = "Aantal broedparen Veldleeuwerik per plot", x = "Jaar",
       colour = "telperiode") +
  theme(legend.position = "bottom")
```

## Verklarende variabelen {#exploratie-variabelen}

### Openheid van het landschap

In De Moeren bevinden zich geen plots in half-gesloten landschap en in de Oostelijke leemstreek slechts 1 plot.
Het gaat om plot VL0582 die enkel in 2021 werd geteld.
Hier werden geen Veldleeuwerikken geteld.
Voor analyses waarbij we ook afwezigheden in beschouwing nemen, zouden we deze plot best verwijderen.
In beide regio's is er vooral geteld in open landschap en minder in half-open landschap.

```{r}
design_openheid <- bezoekenlijst_2018_2022 %>%
  expand(regio, jaar, openheid)
  
bezoekenlijst_2018_2022 %>%
  select(-periode_in_jaar) %>%
  distinct() %>%
  group_by(regio, jaar, openheid) %>%
  summarise(aantal_plots = n()) %>%
  full_join(design_openheid, by = c("regio", "jaar", "openheid")) %>%
  replace(is.na(.), 0) %>%
  arrange(regio, jaar, openheid) %>%
  kable()
```

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
bezoekenlijst_2018_2022 %>%
  select(-periode_in_jaar) %>%
  distinct() %>%
  group_by(regio, jaar, openheid) %>%
  summarise(aantal_plots = n()) %>%
  ggplot(aes(x = openheid, y = aantal_plots, fill = factor(jaar))) +
    geom_bar(stat = "identity") +
    theme(panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank()) + 
    facet_wrap(jaar~regio, scales = "free_y") +
    labs(y = "", x = "Aantal plots per categorie openheid landschap",
         fill = "jaar") +
    theme(legend.position = c(1, 0),
          legend.justification = c(1, 0),
          legend.direction = "horizontal")
```

Het gemiddeld aantal broedparen is steeds hoger in open landschap.
Daar waren ook meer plots.

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
veldleeuwerik_df %>%
  ggplot(aes(x = openheid, y = aantal)) +
  stat_sum(position = position_dodge(width = 0.5), alpha = 0.2) +
  stat_summary(fun.data = mean_cl_boot,
               position = position_dodge(width = 0.5),
               fatten = 4, shape = "square") +
  facet_wrap(jaar~regio, scales = "free_y") +
  labs(y = "Aantal broedparen Veldleeuwerik per plot", 
       x = "Openheid landschap") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1, 0),
        legend.direction = "horizontal")
```

### Soortbeschermingsplan

De plots bevinden zich in beide regio's mestal binnen het soorbeschermingsplan.
In 2022 is dit verschil kleiner.

```{r}
design_sbp <- bezoekenlijst_2018_2022 %>%
  expand(regio, jaar, sbp)
  
bezoekenlijst_2018_2022 %>%
  select(-periode_in_jaar) %>%
  distinct() %>%
  group_by(regio, jaar, sbp) %>%
  summarise(aantal_plots = n()) %>%
  full_join(design_sbp, by = c("regio", "jaar", "sbp")) %>%
  replace(is.na(.), 0) %>%
  arrange(regio, jaar, sbp) %>%
  kable()
```

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
bezoekenlijst_2018_2022 %>%
  select(-periode_in_jaar) %>%
  distinct() %>%
  group_by(regio, jaar, sbp) %>%
  summarise(aantal_plots = n()) %>%
  ggplot(aes(x = sbp, y = aantal_plots, fill = factor(jaar))) +
    geom_bar(stat = "identity") +
    theme(panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank()) + 
    facet_wrap(jaar~regio, scales = "free_y") +
    labs(y = "", x = "Aantal plots binnen en buiten soortbeschermingsplan",
         fill = "jaar") +
    theme(legend.position = c(1, 0),
          legend.justification = c(1, 0),
          legend.direction = "horizontal")
```

Het gemiddeld aantal broedparen lijkt niet te veel te verschillen binnen of buiten het soortbeschermingsplan.

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
veldleeuwerik_df %>%
  ggplot(aes(x = sbp, y = aantal)) +
  stat_sum(position = position_dodge(width = 0.5), alpha = 0.2) +
  stat_summary(fun.data = mean_cl_boot,
               position = position_dodge(width = 0.5),
               fatten = 4, shape = "square") +
  facet_wrap(jaar~regio, scales = "free_y") +
  labs(y = "Aantal broedparen Veldleeuwerik per plot", 
       x = "Soortbeschermingsplan") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1, 0),
        legend.direction = "horizontal")
```

### Interactie openheid en soortbeschermingsplan

```{r}
design_openheid <- bezoekenlijst_2018_2022 %>%
  expand(regio, jaar, openheid, sbp)
  
bezoekenlijst_2018_2022 %>%
  select(-periode_in_jaar) %>%
  distinct() %>%
  group_by(regio, jaar, openheid, sbp) %>%
  summarise(aantal_plots = n()) %>%
  full_join(design_openheid, by = c("regio", "jaar", "openheid", "sbp")) %>%
  replace(is.na(.), 0) %>%
  arrange(regio, jaar, openheid, sbp) %>%
  kable()
```

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
bezoekenlijst_2018_2022 %>%
  select(-periode_in_jaar) %>%
  distinct() %>%
  group_by(regio, jaar, openheid, sbp) %>%
  summarise(aantal_plots = n()) %>%
  ggplot(aes(x = openheid, y = aantal_plots, fill = sbp)) +
    geom_bar(stat = "identity") +
    theme(panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank()) + 
    facet_wrap(jaar~regio, scales = "free_y") +
    labs(y = "", x = "Aantal plots per categorie",
         fill = "sbp") +
    theme(legend.position = c(1, 0),
          legend.justification = c(1, 0),
          legend.direction = "horizontal")
```

## Afstanden {#exploratie-afstanden}

Voor elke waarneming van een broedgeval (of aanwijzing voor een broedpaar) hebben we een afstand tussen 0 en 300 m.
Deze hebben min of meer dezelfde verdeling in alle jaren en over alle regio's.
De minima in De Moeren zijn wel opvallend hoog.

```{r}
# Dupliceer rijen volgens aantal (elke rij is 1 individu)
veldleeuwerik_presences2 <- 
  tibble(
    veldleeuwerik_presences[rep(seq_len(dim(veldleeuwerik_presences)[1]), 
                  veldleeuwerik_presences$aantal), , 
                  drop = FALSE], 
    row.names = NULL
  ) %>%
  mutate(aantal = 1) %>%
  rowid_to_column("id") # Elke rij unieke id

veldleeuwerik_presences2 %>% 
  st_drop_geometry() %>%
  group_by(regio, jaar) %>%
  summarise(min = min(distance2plot, na.rm = TRUE), 
            mediaan = median(distance2plot, na.rm = TRUE),
            gemiddelde = mean(distance2plot, na.rm = TRUE),
            max = max(distance2plot, na.rm = TRUE),
            varantie = var(distance2plot, na.rm = TRUE)) %>%
  kable(digits = 1)
```

```{r, fig.width=9.26, fig.height=6.09, fig.align='center'}
veldleeuwerik_presences2 %>%
  ggplot() +
    geom_histogram(aes(x = distance2plot, fill = stratum), bins = 30) +
    scale_y_continuous(breaks = scales::pretty_breaks()) +
    facet_wrap(jaar~regio, scales = "free_y") +
    labs(y = "Aantal broedparen", x = "Afstand (m)") +
    theme(legend.position = "bottom",
          legend.direction = "horizontal")
```

# Densiteitsschattingen 2018-2022 {#dens-2018-2022}

## Inleiding tot distance sampling {#inleiding-distance}

Distance sampling is een techniek om de abundantie en/of densiteit van biologische populaties te schatten op basis van een steekproef uit de populatie.
Het is namelijk in de praktijk quasi nooit mogelijk om elk individu te tellen.
Dieren staan constant in beweging en interageren op allerlei manier met elkaar en hun omgeving.
Afhankelijk van de eigenschappen van een soort en de omgeving kan de de detectiekans van een soort verschillen.
Een idee over de detectiekans van een soort is bijgevolg van belang om een schatting van de volledige populatie te maken vanuit de steekproef.
Een andere bekende techniek om abundanties te schatten is capture-recapture.
Hierbij zit de informatie over de detectiekans in de vangstgeschiedenis van verschillende individuen.
In distance sampling daarentegen zit informatie over detecteerbaarheid vervat in de detectieafstanden.
Het onderliggende idee van beide benaderingen is dat, als we de detectiekans kunnen schatten voor de individuen die we detecteren, we ook kunnen schatten hoeveel er niet opgemerkt werden.
Op basis van die schatting van detectiekans, kunnen we de waargenomen tellingen corrigeren voor individuen die op de bemonsterde plots zijn gemist.
Het voordeel van distance sampling ten opzichte van capture-recapture is dat het niet vereist is dat individuen worden gemarkeerd en opnieuw worden gevangen/waargenomen in de loop van de tijd.
Bovendien kan slechts een enkele steekproef van de populatie voldoende zijn [@buckland2015; @buckland2001].\

Wanneer we het over distance sampling hebben in dit rapport, spreken we eigenlijk over conventional distance sampling (CDS).
In CDS worden de data gebundeld voor het schatten van de detectiekans.
Dit is in tegenstelling tot hierarchical distance sampling (HDS), waarbij de focus ligt op lokale populatiegroottes van de steekproefeenheden door het maken van expliciete modellen die de variatie in populatiegrootte tussen steekproefeenheden verklaren [@kéry2016].
HDS wordt hier verder niet besproken.
De belangrijkste aannames van de CDS-methode zijn [@buckland2001, hoofdstuk 2]:

1.  Dieren zijn uniform verdeeld over de ruimte (steekproefdesign)\
    (= random plaatsing van steekproefeenheden t.o.v. verdeling dieren)

2.  Detectiekans is een functie van afstand en is gelijk aan 1 op afstand 0 (model)

3.  Individuen worden gedetecteerd op hun oorspronkelijke locatie (model)

4.  Afstanden worden foutloos gemeten (model)

Distance sampling is erg populair bij het tellen van vogels met behulp van punttransecten [@rosenstock2002; @buckland2001; @roodbergen2011].
Een punttransect is een cirkelvormige plot met radius $w$ waar een waarnemer vanuit een centraal punt de radiale afstand $r_i$ meet tot elk van de gedetecteerde individuen $i = 1, ..., n$ met $n$ het totaal aantal waarnemingen (Fig. \@ref(fig:punttransect-plot)).
$w$ wordt ook wel de afknotafstand genoemd.

```{r punttransect-plot, fig.cap = "Punttransect met radius $w$ en observatie $i$ op afstand $r$."}
circle_fun <- function(center = c(0, 0), diameter = 600, npoints = 100) {
  r <- diameter / 2
  tt <- seq(0, 2 * pi, length.out = npoints)
  xx <- center[1] + r * cos(tt)
  yy <- center[2] + r * sin(tt)
  return(data.frame(x = xx, y = yy))
}

ggplot(data = circle_fun()) +
  geom_segment(aes(x = 0, y = 0, xend = 300, yend = 0)) +
  geom_text(aes(x = 150, y = 0, label = "w"), nudge_y = 25) +
  geom_point(aes(x = -100, y = 200), shape = "\U1F986", size = 10) +
  geom_segment(aes(x = 0, y = 0, xend = -100, yend = 200)) +
  geom_text(aes(x = -50, y = 100), label = "r[i]", nudge_y = 20, nudge_x = 20, parse = TRUE) +
  geom_path(aes(x, y), colour = "red") + 
  geom_point(aes(x = 0, y = 0), colour = "red", size = 2) +
  labs(x = "", y = "") +
  coord_fixed() +
  theme_void()
```

## Data selectie en preparatie {#preparatie-distance}

We beschouwen alle plots van 2018-2021 en voegen enkel plots van 2022 toe als ze minstens eenmaal geteld zijn in een van de voorgaande jaren.

```{r}
plots_old <- bezoekenlijst_2018_2022 %>%
  filter(jaar != 2022) %>%
  distinct(plotnaam) %>%
  pull()

veldleeuwerik_2018_2022_reduced <- veldleeuwerik_presences %>%
  filter(plotnaam %in% plots_old)

bezoekenlijst_2018_2022_reduced <- bezoekenlijst_2018_2022 %>%
  filter(plotnaam %in% plots_old)
```

De eerste dataset wordt gebruikt om de detectiecurve te fitten (zie verder).
We hebben een kolom `object` nodig: volgnummer voor elke waarneming; een kolom `size`: aantal broedparen per waarneming; een kolom `distance`: afstand tot elke waarneming; kolommen met covariaten: `regio`en `jaar`.

```{r}
veldleeuwerik_distance <- veldleeuwerik_2018_2022_reduced %>%
  st_drop_geometry() %>%
  select(object = oid, size = aantal, distance = distance2plot, 
         regio, jaar) %>%
  mutate(jaar = as.character(jaar))
```

Om abundanties te schatten, moeten we de oppervlakte van de regio's berekenen voor extrapolatie.
We trekken een buffer van 300 m rond het steekproefkader: half-open landschap (HOL) in De Moeren, en open (OL) en half-open landschap in de Oostelijke leemstreek.

```{r}
# Lees steekproefkader in
steekproefkader <- tar_read(steekproefkader_finaal, store = targets_store)

# Selectie en buffer
perimeters_strata <- steekproefkader %>%
  filter(openheid_klasse %in% c("HOL", "OL"),
         !(Naam == "De Moeren" & openheid_klasse == "HOL")) %>%
  st_buffer(dist = 300) %>%
  group_by(Naam) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup()

# Visualisatie
p_moeren <- perimeters_strata %>%
  filter(Naam == "De Moeren") %>%
  ggplot() +
    geom_sf() +
    facet_grid(~Naam)

p_leemstreek <- perimeters_strata %>%
  filter(Naam == "Oostelijke leemstreek") %>%
  ggplot() +
    geom_sf() +
    facet_grid(~Naam)

# Bereken oppervlaktes van de regio's
areas <- perimeters_strata %>% 
  mutate(Area = as.numeric(st_area(geometry)) / 1e6) %>%
  select(regio = Naam, Area) %>%
  st_drop_geometry()
table_area <- areas %>%
  rename(`oppervlakte (km²)` = Area) %>%
  tableGrob(rows = NULL)

# Plot
grid.arrange(p_moeren, p_leemstreek, table_area, 
             layout_matrix = rbind(c(1, 2), c(1, 3)))
```

We willen een schatting voor elke regio in elk jaar.
We definiëren dus de strata regio-jaar.
We maken daarom dataframes om de abundanties en densiteiten te berekenen.
`Region_table` met de oppervlaktes per stratum (regio-jaar), `sample_table` geeft aan welke plots in welke regio's voorkomen en met welke effort is geleverd (effort is gelijk aan het aantal beschouwde telperiodes per jaar) en `obs_table` die aangeeft welke waarnemingen in welke plots en strata zitten.

```{r}
# Oppervlakte per stratum
region_table <- bezoekenlijst_2018_2022_reduced %>%
  distinct(regio, jaar) %>%
  full_join(areas, by = "regio") %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - ")) %>%
  select(Region.Label, Area)

# Effort per sample en plot per stratum
effort <- veldleeuwerik_2018_2022_reduced %>%
  pull(periode_in_jaar) %>%
  unique() %>%
  length()

sample_table <- bezoekenlijst_2018_2022_reduced %>%
  distinct(plotnaam, regio, jaar) %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - "),
         Effort = effort) %>%
  select(Sample.Label = plotnaam, Region.Label, Effort)

# Waarnemingen per welke plots en strata
obs_table <- veldleeuwerik_2018_2022_reduced %>%
  st_drop_geometry() %>%
  select(object = oid, Region.Label, Sample.Label = plotnaam)
```

Ten slotte zet de conversiefactor de afstanden om van meter naar vierkante kilometer (= 100 ha).

```{r}
# Conversiefactor van meter naar 100 hectare
conversion_factor <- convert_units("meter", NULL, "Square kilometer")
```

## Model specificatie {#specificatie-distance}

We voeren de distance sampling analyses uit met behulp van de **Distance** package [@R-Distance; @miller2019].
We maken een model voor de probabiliteit dat een Veldleeuwerik wordt gedetecteerd gegeven we de afstand tot het individu weten.
Dit model is de detectiefunctie/-curve en wordt genoteerd als $g(r;\boldsymbol \theta)$ met $r$ de radiale afstand van waarneming tot teller/telpunt en $\boldsymbol \theta$ een vector van parameters die geschat moeten worden.
Het doel is de gemiddelde kans op detectie ($p$) te bepalen.
Dit is het gemiddelde over afstand van 0 m tot de afknotafstand $w$, in ons geval $w = 300$.
De term $\frac{2r}{w^2}$ is nodig om rekening te houden met de geometrie van de plot (cirkel).

$$
p = \int_0^w\frac{2r}{w^2}g(r;\boldsymbol \theta)\,dr
$$

$p$ is dus de oppervlakte onder de detectiecurve.
Figuur \@ref(fig:detectie-plot) toont een fictief voorbeeld van een histogram met afstanden van 0 tot 300 meter ($w = 300$).
Hoe groter de afstand, hoe minder waarnemingen en dus lager de detectiekans.
Moest het aantal waarnemingen niet afnemen over de afstand, zouden de afstanden uniform verdeeld zijn zoals de rode box.
Alles zou gezien zijn en de detectiekans $p = 1$.
De blauwe curve is een half-normale detectiecurve gefit op de data.
De oppervlakte onder de curve binnen de box is de gemiddelde detectiekans (de geschatte fractie dieren die gezien zijn).
De oppervlakte boven de curve binnen de box de geschatte fractie dieren die gemist zijn.
Als we de gemiddelde detectiekans weten, kunnen we dus eenvoudig berekenen hoeveel dieren we verwachten als we uitgaan van een uniforme verdeling van dieren over de telcirkel (zie verder).
We controleren er dus voor dat het moeilijker is om dieren te detecteren op grotere afstand, terwijl we er van uitgaan dat er in werkelijkheid evenveel zitten op grotere als op kleinere afstanden.

```{r detectie-plot, fig.cap = "Histogram en detectiecurve gefit op 1000 gesimuleerde datapunten uit de half-normale verdeling met parameter $\\sigma = 120$ en afknotafstand 300 m. De oppervlakte onder de curve binnen de rode box is de gemiddelde detectiekans $p$."}
# Simulate distance data for point transect
set.seed(1234)
dist_data <- sim.pdata(N = 1000, sigma = 120, B = 300)

# Fit model
ds_model <- ds(dist_data$d, key = "hn", truncation = 300, transect = "point", 
               dht_group = FALSE, convert_units = conversion_factor)

# Plot detection curve
plot_detection_curve(ds_model) +
  geom_rect(aes(xmin = 0, xmax = 300, ymin = 0, ymax = 1),
            colour = "red", fill = alpha("white", 0)) +
  geom_text(aes(x = 150, y = 0.6), label = expression(italic("g(r;"*theta*")")))
```

Voor de formulatie van de detectiefunctie beschouwen we half-normal en hazard-rate sleutelfuncties die we laten afhangen van covariaten regio en jaar.
Dit wordt ook wel multiple-covariate distance sampling (MCDS) genoemd.
De detectiekans wordt dan berekend conditioneel aan de waargenomen waarden van de covariaten.

```{r}
match_variables <- c("regio", "jaar")
```

$$
p(\mathbf{z_i}) = \int_0^w\frac{2r}{w^2}g(r, \mathbf{z_i};\boldsymbol \theta)\,dr
$$

Met $\mathbf{z_i}$ een vector van $J$ (hier $J=$ `r length(match_variables)`) covariaten geassocieerd met observatie $i$.

De half-normal sleutelfunctie is van de vorm

$$
g(r, \mathbf{z};\boldsymbol \theta) = \exp{\left( -\frac{r^2}{2\sigma(\mathbf{z})^2} \right)}
$$

en de hazard-rate sleutelfunctie

$$
g(r, \mathbf{z};\boldsymbol \theta) = 1 - \exp{\left( \left( -\frac{r}{\sigma(\mathbf{z})}\right)^{-b} \right)}
$$

waarbij de scale parameter in beide gevallen gelijk is aan

$$
\sigma(\mathbf{z}) = \exp{\left( \beta_0 + \sum_{j = 1}^{J} \beta_j z_j \right)}
$$

De hazard-rate key function heeft naast de scale parameter ook nog de shape parameter $b$.  
  
We fitten beide sleutelfuncties met de `ds()` functie in een for-loop.
We fitten modellen zonder covariaten, met alle combinaties van covariaten en beschouwen ook tweewegsinteracties tussen de covariaten.
De interactie regio met openheid kan niet gefit worden omdat HOL niet in De Moeren voorkomt.
In de twee modellen zonder covariaten kunnen aanpassingstermen toegevoegd worden om een betere fit te krijgen tussen de curve en de data.
Om te hoge flexibiliteit van dergelijke detectiefunctiemodellen te beperken, bijvoorbeeld aangeraden in aanwezigheid van overdispersie [@buckland2015], beperken we het aantal aanpassingstermen tot maximaal 2.
De `ds()` functie voegt zelf aanpassingstermen toe aan de sleutelfunctie om de fit te verbeteren tot er geen verbetering meer in AIC is.

```{r, cache=TRUE}
veldleeuwerik_dist_2018_2022_hn0 <- ds(data = veldleeuwerik_distance, 
  key = "hn", truncation = 300, transect = "point", dht_group = FALSE,  
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table, max_adjustments = 2,
  monotonicity = "strict")

veldleeuwerik_dist_2018_2022_hr0 <- ds(data = veldleeuwerik_distance, 
  key = "hr", truncation = 300, transect = "point", dht_group = FALSE,  
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table, max_adjustments = 2,
  monotonicity = "strict")

veldleeuwerik_dist_2018_2022_hn1 <- ds(data = veldleeuwerik_distance, key = "hn", 
  formula = ~regio, adjustment = NULL, truncation = 300, 
  transect = "point", dht_group = FALSE, 
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2018_2022_hr1 <- ds(data = veldleeuwerik_distance, key = "hr", 
  formula = ~regio, adjustment = NULL, truncation = 300, 
  transect = "point", dht_group = FALSE, 
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2018_2022_hn2 <- ds(data = veldleeuwerik_distance, key = "hn", 
  formula = ~jaar, adjustment = NULL, truncation = 300, 
  transect = "point", dht_group = FALSE, 
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2018_2022_hr2 <- ds(data = veldleeuwerik_distance, key = "hr", 
  formula = ~jaar, adjustment = NULL, truncation = 300, 
  transect = "point", dht_group = FALSE, 
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2018_2022_hn3 <- ds(data = veldleeuwerik_distance, key = "hn", 
  formula = ~regio*jaar, adjustment = NULL, truncation = 300, 
  transect = "point", dht_group = FALSE, 
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2018_2022_hr3 <- ds(data = veldleeuwerik_distance, key = "hr", 
  formula = ~regio*jaar, adjustment = NULL, truncation = 300, 
  transect = "point", dht_group = FALSE, 
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table)
```


## Model selectie {#selectie-distance}

We vergelijken de AIC van de verschillende modellen met de functie `summarize_ds_models()`.
Als het verschil tussen AIC's kleiner is dan 2, kiezen we het eenvoudigste van deze modellen (model met minste parameters).
Modellen met vergelijkbare AIC's hebben vergelijkbare geschatte detectiekansen, dus in de praktijk is er weinig verschil in de keuze tussen deze modellen [@miller2019].

```{r, cache=TRUE}
summarize_ds_models2(
  veldleeuwerik_dist_2018_2022_hn0, veldleeuwerik_dist_2018_2022_hr0, 
  veldleeuwerik_dist_2018_2022_hn1, veldleeuwerik_dist_2018_2022_hr1,
  veldleeuwerik_dist_2018_2022_hn2, veldleeuwerik_dist_2018_2022_hr2,
  veldleeuwerik_dist_2018_2022_hn3, veldleeuwerik_dist_2018_2022_hr3) %>%
  kable()
```

Het Hazard-rate model waarbij de detectiekans afhankelijk is van regio en jaar in interactie scoort het best.

## Model fit {#fit-distance}

Om te controleren of ons model goed past bij de data ("goodness of fit") maken we een Q-Q plot waarbij de cumulatieve distributiefunctie van de gefitte detectiefunctie (CDF) wordt vergeleken met de distributie van de data (EDF).
De Cramér-von Mises test kwantificeert de informatie van de Q-Q-plot door te testen of punten van de EDF en CDF uit dezelfde verdeling komen [@buckland2015; @miller2019].
Voor studies met punttransecten geven kansdichtheidsfunctieplots ook een goed idee over model fit.

```{r}
par(mfrow = c(1, 2))
von_mises <- gof_ds(veldleeuwerik_dist_2018_2022_hr3)
von_mises
plot(veldleeuwerik_dist_2018_2022_hr3, pdf = TRUE, showpoints = FALSE)
par(mfrow = c(1, 1))
```

De visuele fit van de Q-Q-plot ziet er goed uit maar Cramér-von Mises test suggereert dat het model niet goed past bij de data ($W^2 =$ `r round(von_mises$dsgof$CvM$W, digits = 3)`, $p =$ `r round(von_mises$dsgof$CvM$p, digits = 3)`).
Ook de kansdichtheidsfunctieplot toont geen ideale fit.
Inderdaad, als we kijken naar de verdeling van de afstanden, zien we dat de detectiekans niet altijd afneemt over de afstand (zie \@ref(discussie-distance)).
Het is dus niet mogelijk om een detectiecurve perfect te fitten.

```{r}
plot_detection_curve(veldleeuwerik_dist_2018_2022_hr3, plot_average_fit = FALSE, 
                     n_breaks = 60)
```

Daarom fitten we dit model opnieuw waarbij we de afstanden groeperen in intervallen van 50 m.

```{r, cache=TRUE}
veldleeuwerik_dist_2018_2022_hr3_binned <- ds(data = veldleeuwerik_distance, key = "hr", 
        formula = ~regio*jaar, adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        cutpoints = c(0, 50, 100, 150, 200, 250, 300),
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)
```

De fit ziet er beter uit dan voordien.

```{r}
plot(veldleeuwerik_dist_2018_2022_hr3_binned, pdf = TRUE, showpoints = FALSE)
```

We selecteren het intervalmodel met Hazard-rate sleutelfunctie waarbij de detectiekans afhankelijk is van 
regio en jaar in interactie als finale model.

```{r}
veldleeuwerik_dist_2018_2022_model <- veldleeuwerik_dist_2018_2022_hr3_binned
veldleeuwerik_covars <- c("regio", "jaar")
```

## Resultaten {#resultaten-distance}

We hebben de studieregio in $2\times5$ strata opgesplits: elk jaar voor De Moeren en de Oostelijke leemstreek.
Beschouw $A(s)$ de totale oppervlakte van stratum $s$ tot waar we de abundantieschatting willen extrapoleren en $a(s)$ het gesampelde gebied.
De oppervlakte zal niet wijzigen over de jaren maar enkel tussen de regio's.

$$
a(s) = \pi w^2 T
$$

Met $T$ het aantal plots ($n_p$) vermenigvuldigd met het aantal bezoeken (effort).
In ons geval hebben we dus $a(s) = \pi 300^2 n_p$ `r effort`.
Dan is de geschatte abundantie in het gesampelde gebied voor elk stratum $s$:

$$
\hat{N}_C(s) = \sum_{i=1}^n \frac{c_i(s)}{\hat{p}(\mathbf{z_i})}
$$ Met $c_i(s)$ de clustergrootte in stratum $s$ voor waarneming $i$.

Meestal is $c_i(s) = 1$, maar soms bestaat een waarneming uit meerdere individuen die gezien waren op dezelfde afstand op hetzelfde moment.
De geschatte abundantie in het gesampelde gebied kan dan worden opgeschaald naar de totale oppervlakte van het stratum via:

$$
\hat{N}(s) = \frac{A(s)}{a(s)}\hat{N}_C(s)
$$

De geschatte densiteit in stratumm $s$ is dan $\hat{N}(s) / A(s)$.
De abundanties kunnen ook opgeteld worden voor een totale schatting $\hat{N}_C$.
Een maat voor de gemiddelde detectiekans $\hat{P}_a$ is dan:

$$
\hat{P}_a = \frac{n}{\hat{N}_C}
$$

De onzekerheid op de abundantie- en densiteitsschattingen komt van twee origines:

1.  Detectiefunctie: Onzekerheid in parameterschattingen ($\boldsymbol \theta$)
2.  Trefkans: Bemonsteringsvariabiliteit als gevolg van verschillen in het aantal waarnemingen per transect

De onzekerheid werd berekend m.b.v. de standaard opties in de `ds()` functie.
Zie @miller2019 en verwijzingen daarin voor meer informatie over de preciese berekeningen.
De onzekerheid in de volgende resultaten zijn telkens 95 % betrouwbaarheidsintervallen.

De detectiekansen en standard errors zijn verschillend per regio en jaar:

```{r}
cbind(veldleeuwerik_dist_2018_2022_model$ddf$data, 
      "p(z)" = predict(veldleeuwerik_dist_2018_2022_model, 
                       se.fit = TRUE)$fitted, 
      "standard error" = predict(veldleeuwerik_dist_2018_2022_model, 
                                 se.fit = TRUE)$se) %>%
  select(all_of(veldleeuwerik_covars), "p(z)", "standard error") %>%
  distinct() %>%
  arrange(jaar, regio) %>%
  kable()
```

```{r}
design_plot <- matrix(rep(0, 10 * 10), ncol = 10, byrow = TRUE)
design_plot[, 1] <- 1
design_plot[2, 2] <- 1
design_plot[3, 3] <- 1
design_plot[4, 4] <- 1
design_plot[5, 5] <- 1
design_plot[6, 6] <- 1
design_plot[7:10, 2] <- 1
design_plot[7, c(3, 7)] <- 1
design_plot[8, c(4, 8)] <- 1
design_plot[9, c(5, 9)] <- 1
design_plot[10, c(6, 10)] <- 1

labels_plot <- paste(c("De Moeren", "Oostelijke leemstreek", 
                       rep(c("De Moeren", "Oostelijke leemstreek"), each = 4)),
                     c(2018, 2018, rep(2019:2022, 2)), sep = " - ")

design_plot %>%
  data.frame() %>%
  `rownames<-`(labels_plot) %>%
  `colnames<-`(names(
    veldleeuwerik_dist_2018_2022_model$ddf$ds$aux$ddfobj$scale$parameters)) %>%
  kable()

plot_detection_curve(veldleeuwerik_dist_2018_2022_model, design_mat = design_plot, 
                     labels = labels_plot, n_breaks = 6) +
  scale_colour_manual(values = c(inbo_palette(), "red"))
```

De gemiddelde detectiekans $\hat{P}_a$ is gelijk aan `r round(veldleeuwerik_dist_2018_2022_model$dht$individuals$average.p, digits = 3)`.

```{r}
summary_veldleeuwerik_dist <- summary(veldleeuwerik_dist_2018_2022_model)

summary_results_veldleeuwerik_dist <- bind_rows(
  summary_veldleeuwerik_dist$dht$individuals$D %>%
    mutate(variable = "density",
           type = "Aantal broedparen per 100 ha"),
  summary_veldleeuwerik_dist$dht$individuals$N %>%
    mutate(variable = "abundance",
           type = "Totaal aantal broedparen")
  ) %>%
  filter(Label != "Total") %>%
  separate(Label, into = c("regio", "jaar"), sep = " - ")
```

Per stratum (combinatie regio en jaar) krijgen we dan de abundanties:

```{r}
summary_results_veldleeuwerik_dist %>%
  filter(variable == "abundance") %>%
  select(regio, jaar, schatting = Estimate, se, lcl, ucl) %>%
  arrange(regio, jaar) %>%
  kable(digits = 3)
```

Densiteiten:

```{r}
summary_results_veldleeuwerik_dist %>%
  filter(variable == "density") %>%
  select(regio, jaar, schatting = Estimate, se, lcl, ucl) %>%
  arrange(regio, jaar) %>%
  kable(digits = 3)
```

We visualiseren de densiteit over de jaren per regio.

```{r}
summary_results_veldleeuwerik_dist %>%
  filter(variable == "density") %>%
  ggplot(aes(x = jaar, y = Estimate, colour = regio)) + 
    geom_point(size = 4) + 
    geom_errorbar(aes(ymin = lcl, ymax = ucl), width = 0.25) +
    scale_y_continuous(limits = c(0, NA)) +
    facet_wrap(~regio, scales = "free_y") +
    labs(x = "", y = "Aantal broedparen per 100 ha", 
         title = "Veldleeuwerik - densiteit") +
    theme(legend.position = "")
```

## Discussie {#discussie-distance}

@roodbergen2011 hadden voor de Veldleeuwerik gelijkaardige problemen om een passende detectiecurve te fitten.
Zij stellen dat dit kan worden veroorzaakt doordat vogels zich verplaatsen als reactie op de waarnemer of het afronden van afstanden door waarnemers.
Dit laatste is bij ons zeker niet het geval doordat waarnemers een punt aanduiden op de kaart via een app en niet manueel een afstand invoeren.
Het probleem ligt dus waarschijnlijk in het gedrag van de soort.
Veldleeuwerikken vliegen gemakkelijk op bij verstoring waardoor we minder waarnemingen zien op kleinere afstanden en dan weer een groter aantal zien rond ca.
75-100 m.
Bovendien is de soort nog gemakkelijk te horen op grotere afstand zonder exact de locatie te weten.
Hierdoor zien we opnieuw een stijging rond 250 m.
@roodbergen2011 fitten daarom voor deze soort een detectiecurve m.b.v. afstandsintervallen.
Wij groepeerden daarom de afstanden per 50 m.
Hoewel de fit er visueel beter uitzag, waren de densiteitsschattingen en hun onzekerheid quasi identiek aan de eerdere resultaten zonder groepering (resultaten niet getoond).

We kunnen deze resultaten vergelijken met andere technieken.
Het gemiddelde en het maximum aantal en broedparen over de telperiodes.
Opgeteld per jaar en per regio.
Omgerekend naar densiteit door te delen door de bezochte oppervlakte.
Voor het gemiddelde is ook met absensies rekening gehouden (maakt voor maximum niet uit).
De gemiddeldes liggen lager, terwijl de maxima goed overeenkomen met de resultaten van distance sampling.
@wiersma2021 gebruiken de maxima om de densiteiten te schatten.
Ze stellen dat dit minimumschattingen zijn omdat ze niet voor onvolledige trefkans hebben gecorrigeerd.
Wij doen dat wel via distance sampling, maar in het geval van de Veldleeuwerik zien we hier geen groot verschil tussen het gebruik van maxima of distance sampling.

In de volgende figuur zijn de gemiddeldes en maxima aangegeven door bar-plots en waarbij de resultaten van distance sampling erover zijn geplot.

```{r}
# Bereken aantal plots per regio per jaar 2018-2022
plots_per_regiojaar <- bezoekenlijst_2018_2022_reduced %>%
  group_by(regio, jaar) %>%
  summarise(aantal_plots = n_distinct(plotnaam)) %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - "))

# Oppervlakte telcirkels
cirkelopp <- pi * 300^2

distance_plot_df <- summary_results_veldleeuwerik_dist %>%
  filter(variable == "density") %>%
  mutate(jaar = as.integer(jaar))

veldleeuwerik_df %>%
  filter(plotnaam %in% plots_old) %>%
  # Bepaal voor elke plot het gemiddeld aantal individuen en maximum over
  # de telperiodes per jaar
  group_by(plotnaam, jaar, periode_in_jaar) %>%
  mutate(totaal = sum(aantal)) %>%
  group_by(plotnaam, jaar) %>%
  mutate(gemiddelde = mean(totaal),
            maximum = max(totaal)) %>%
  ungroup() %>%
  select(-c(periode_in_jaar, aantal, totaal)) %>%
  distinct() %>%
  
  # Bereken dan het totaal aantal individuen over alle plots (som)
  group_by(Region.Label) %>%
  summarise(tot_gemiddelde = sum(gemiddelde),
            tot_max = sum(maximum)) %>% 
  
  # Deel door aantal plots om aantal broedkoppels per plot te krijgen
  full_join(plots_per_regiojaar, by = "Region.Label") %>%
  mutate(tot_gemiddelde_plots = (tot_gemiddelde / aantal_plots) / cirkelopp * 1e6,
         tot_max_plots = (tot_max / aantal_plots) / cirkelopp * 1e6) %>%
  pivot_longer(cols = c("tot_gemiddelde_plots", "tot_max_plots"), 
               names_to = "categorie", values_to = "Estimate") %>%
  
  # Visualiseer
  ggplot(aes(x = jaar, y = Estimate)) + 
    geom_bar(aes(fill = regio), stat = "identity") + 
    geom_point(data = distance_plot_df, aes(x = jaar, y = Estimate), size = 4) + 
    geom_errorbar(data = distance_plot_df, aes(ymin = lcl, ymax = ucl), 
                  width = 0.25) +
    labs(x = "", y = "Aantal broedparen Veldleeuwerik per 100 ha") +
    theme(legend.position = "") +
    facet_wrap(regio~categorie, labeller = labeller(
      categorie = c(
        "tot_gemiddelde_plots" = "Gemiddeld aantal broedparen per plot",
        "tot_max_plots" = "Maximum aantal broedparen per plot")
      ), scales = "free_y")
```


# Densiteitsschattingen 2022 {#dens-2022}

## Data selectie en preparatie {#preparatie-distance}

We beschouwen alle plots van 2022.

```{r}
veldleeuwerik_2022 <- veldleeuwerik_presences %>%
  filter(jaar == 2022)

design_2022 <- bezoekenlijst_2018_2022 %>%
  filter(jaar == 2022)
```

De eerste dataset wordt gebruikt om de detectiecurve te fitten (zie verder).
We hebben een kolom `object` nodig: volgnummer voor elke waarneming; een kolom `size`: aantal broedparen per waarneming; een kolom `distance`: afstand tot elke waarneming; kolommen met covariaten: `regio`, `sbp` en `openheid`.

```{r}
veldleeuwerik_distance <- veldleeuwerik_2022 %>%
  st_drop_geometry() %>%
  select(object = oid, size = aantal, distance = distance2plot, 
         regio, sbp, openheid)
```

Om abundanties te schatten, moeten we de oppervlakte van de strata berekenen voor extrapolatie.
We trekken een buffer van 300 m rond het steekproefkader: half-open landschap (HOL) in De Moeren, en open (OL) en half-open landschap in de Oostelijke leemstreek. We beschouwen de strata:

-   De Moeren, OL, buiten sbp
-   De Moeren, OL, binnen sbp
-   Oostelijke leemstreek, OL, binnen sbp
-   Oostelijke leemstreek, OL, buiten sbp
-   Oostelijke leemstreek, HOL, binnen sbp
-   Oostelijke leemstreek, HOL, buiten sbp


```{r}
# Lees steekproefkader in
steekproefkader <- tar_read(steekproefkader_finaal, store = targets_store)

# Selectie en buffer
perimeters_strata <- steekproefkader %>%
  filter(openheid_klasse %in% c("HOL", "OL"),
         !(Naam == "De Moeren" & openheid_klasse == "HOL")) %>%
  st_buffer(dist = 300) %>%
  group_by(Naam) %>%
  summarise(geometry = st_union(geometry)) %>%
  ungroup()

# Visualisatie
p_moeren <- perimeters_strata %>%
  filter(Naam == "De Moeren") %>%
  ggplot() +
    geom_sf() +
    facet_grid(~Naam)

p_leemstreek <- perimeters_strata %>%
  filter(Naam == "Oostelijke leemstreek") %>%
  ggplot() +
    geom_sf() +
    facet_grid(~Naam)

# Bereken oppervlaktes van de regio's
areas <- perimeters_strata %>% 
  mutate(Area = as.numeric(st_area(geometry)) / 1e6) %>%
  select(regio = Naam, Area) %>%
  st_drop_geometry()
table_area <- areas %>%
  rename(`oppervlakte (km²)` = Area) %>%
  tableGrob(rows = NULL)

# Plot
grid.arrange(p_moeren, p_leemstreek, table_area, 
             layout_matrix = rbind(c(1, 2), c(1, 3)))
```

We willen een densiteitsschatting voor elk stratum.
We maken daarom dataframes om de abundanties en densiteiten te berekenen.
`Region_table` met de oppervlaktes per stratum (regio-openheid-sbp), `sample_table` geeft aan welke plots in welke strata voorkomen en welke effort is geleverd (effort is gelijk aan het aantal beschouwde telperiodes per jaar) en `obs_table` die aangeeft welke waarnemingen in welke plots en strata zitten.

```{r}
# Oppervlakte per stratum
region_table <- design_2022 %>%
  distinct(regio, openheid, sbp) %>%
  full_join(areas, by = "regio") %>%
  mutate(Region.Label = paste(regio, openheid, sbp, sep = " - ")) %>%
  select(Region.Label, Area)

# Effort per sample en plot per stratum
effort <- veldleeuwerik_2022 %>%
  pull(periode_in_jaar) %>%
  unique() %>%
  length()

sample_table <- design_2022 %>%
  distinct(plotnaam, regio, jaar) %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - "),
         Effort = effort) %>%
  select(Sample.Label = plotnaam, Region.Label, Effort)

# Waarnemingen per welke plots en strata
obs_table <- veldleeuwerik_2022 %>%
  st_drop_geometry() %>%
  select(object = oid, Region.Label, Sample.Label = plotnaam)
```

Ten slotte zet de conversiefactor de afstanden om van meter naar vierkante kilometer (= 100 ha).

```{r}
# Conversiefactor van meter naar 100 hectare
conversion_factor <- convert_units("meter", NULL, "Square kilometer")
```

## Model specificatie {#specificatie-distance}

Voor de formulatie van de detectiefunctie beschouwen we half-normal en hazard-rate sleutelfuncties die we laten afhangen van covariaten regio, sbp en openheid.

```{r}
match_variables <- c("regio", "sbp", "openheid")

# We maken formules uit combinaties van alle variabelen
combos <- sapply(seq(length(match_variables)), function(i) {
  as.list(as.data.frame(combn(x = match_variables, m = i)))
})
combos <- unlist(combos, recursive = FALSE)

# Combinaties zonder interacties
forms1 <- sapply(combos, function(x) {
  as.formula(paste0("~", paste(x, collapse = "+")))
  })

# Combinaties interacties
forms2 <- sapply(combos, function(x) {
  if (length(x) == 2) {
  as.formula(paste0("~", paste(x, collapse = "*")))
  }
  })
forms2[sapply(forms2, is.null)] <- NULL
forms2 <- forms2[-3] # remove interaction regio openheid

# Voeg combinaties samen
forms <- c(forms1, forms2)
```

We fitten beide sleutelfuncties met de `ds()` functie in een for-loop.
We fitten modellen zonder covariaten, met alle combinaties van covariaten en beschouwen ook tweewegsinteracties tussen de covariaten.
De interactie regio met openheid kan niet gefit worden omdat HOL niet in De Moeren voorkomt.
In de twee modellen zonder covariaten kunnen aanpassingstermen toegevoegd worden om een betere fit te krijgen tussen de curve en de data.
Om te hoge flexibiliteit van dergelijke detectiefunctiemodellen te beperken, bijvoorbeeld aangeraden in aanwezigheid van overdispersie [@buckland2015], beperken we het aantal aanpassingstermen tot maximaal 2.
De `ds()` functie voegt zelf aanpassingstermen toe aan de sleutelfunctie om de fit te verbeteren tot er geen verbetering meer in AIC is.

```{r, cache=TRUE}
# Key functions
keys <- c("hn", "hr")

# Null models
veldleeuwerik_dist_2022_hn0 <- ds(data = veldleeuwerik_distance, 
  key = "hn", truncation = 300, transect = "point", dht_group = FALSE,  
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table, max_adjustments = 2,
  monotonicity = "strict")

veldleeuwerik_dist_2022_hr0 <- ds(data = veldleeuwerik_distance, 
  key = "hr", truncation = 300, transect = "point", dht_group = FALSE,  
  convert_units = conversion_factor, region_table = region_table, 
  sample_table = sample_table, obs_table = obs_table, max_adjustments = 2,
  monotonicity = "strict")

out_models <- list(veldleeuwerik_dist_2022_hn0, 
                   veldleeuwerik_dist_2022_hr0)
model_names <- c("veldleeuwerik_dist_2022_hn0", 
                 "veldleeuwerik_dist_2022_hr0")

# Sla de gefitte models op op deze locatie
model_path <- "./src/markdown/mas/distance_models/"

# Loop over formules en over key functions
for (i in seq_len(length(forms))) {
  f <- as.character(forms[i]) # f is de formule
  
  for (k in keys) {
    # Naam voor model
    mod_name <- paste0("veldleeuwerik_dist_2022_", k, i)
    file <- paste0(model_path, mod_name, ".rds")
    
    # Sla model op als het nog niet bestaat en lees het in anderzijds
    if (file.exists(file)) {
      det_model <- readRDS(file)
      assign(mod_name, det_model)
      print(paste0("Model '", mod_name, "' fitted. ", 
                   "Formula: '", f, "'. Key: '", k, "'."))
    } else {
      det_model <- ds(data = veldleeuwerik_distance, key = k, 
        formula = as.formula(f), adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)
    
      print(paste0("Model '", mod_name, "' fitted. ", 
                   "Formula: '", f, "'. Key: '", k, "'."))
      
      # Sla gefitte model op
      assign(mod_name, det_model)
      saveRDS(det_model, file = file)
    }
    # Put models and model names in list 
    out_models <- c(out_models, list(det_model))
    model_names <- c(model_names, mod_name)
  }
}

names(out_models) <- model_names
```


## Model selectie {#selectie-distance}

We vergelijken de AIC van de verschillende modellen.
Als het verschil tussen AIC's kleiner is dan 2, kiezen we het eenvoudigste van deze modellen (model met minste parameters).
We tonen enkel de modellen met $\Delta$AIC <= 20.

```{r, cache=TRUE}
summarize_ds_models2(out_models) %>%
  filter(`$\\Delta$AIC` <= 20) %>%
  kable()
```

De volgende hazard-rate modellen konden niet gefit worden (Hessian = `NA`):

-   \~regio+jaar+openheid
-   \~regio+sbp+openheid
-   \~regio+jaar+sbp+openheid
-   \~regio\*jaar
-   \~sbp\*openheid

Het Hazard-rate model waarbij de detectiekans afhankelijk is van jaar en openheid scoort het best.
Op basis van dit model testen we nog enkele combinaties waarbij we interacties tussen elke combinatie van twee variabelen toevoegen (niet regio\*openheid).

```{r, cache=TRUE}
veldleeuwerik_dist_2022_hr21 <- ds(data = veldleeuwerik_distance, key = "hr", 
        formula = ~regio*jaar + openheid, adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2022_hr22 <- ds(data = veldleeuwerik_distance, key = "hr", 
        formula = ~sbp*jaar + openheid, adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2022_hr23 <- ds(data = veldleeuwerik_distance, key = "hr", 
        formula = ~jaar + openheid*sbp, adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)

veldleeuwerik_dist_2022_hr24 <- ds(data = veldleeuwerik_distance, key = "hr", 
        formula = ~regio*jaar + openheid*sbp, adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)

summarize_ds_models2(
  veldleeuwerik_dist_2022_hr9, veldleeuwerik_dist_2022_hr19,
  veldleeuwerik_dist_2022_hr21, veldleeuwerik_dist_2022_hr22, veldleeuwerik_dist_2022_hr23,
  veldleeuwerik_dist_2022_hr24
  ) %>%
  kable()
```

We selecteren het Hazard-rate model waarbij de detectiekans afhankelijk is van sbp, jaar en openheid met sbp en jaar in interactie.

## Model fit {#fit-distance}

Om te controleren of ons model goed past bij de data ("goodness of fit") maken we een Q-Q plot waarbij de cumulatieve distributiefunctie van de gefitte detectiefunctie (CDF) wordt vergeleken met de distributie van de data (EDF).
De Cramér-von Mises test kwantificeert de informatie van de Q-Q-plot door te testen of punten van de EDF en CDF uit dezelfde verdeling komen [@buckland2015; @miller2019].
Voor studies met punttransecten geven kansdichtheidsfunctieplots ook een goed idee over model fit.

```{r}
par(mfrow = c(1, 2))
von_mises <- gof_ds(veldleeuwerik_dist_2022_hr22)
von_mises
plot(veldleeuwerik_dist_2022_hr22, pdf = TRUE, showpoints = FALSE)
par(mfrow = c(1, 1))
```

De visuele fit van de Q-Q-plot ziet er goed uit maar Cramér-von Mises test suggereert dat het model niet goed past bij de data ($W^2 =$ `r round(von_mises$dsgof$CvM$W, digits = 3)`, $p =$ `r round(von_mises$dsgof$CvM$p, digits = 3)`).
Ook de kansdichtheidsfunctieplot toont geen ideale fit.
Inderdaad, als we kijken naar de verdeling van de afstanden, zien we dat de detectiekans niet altijd afneemt over de afstand (zie \@ref(discussie-distance)).
Het is dus niet mogelijk om een detectiecurve perfect te fitten.

```{r}
plot_detection_curve(veldleeuwerik_dist_2022_hr22, plot_average_fit = FALSE, 
                     n_breaks = 60)
```

Daarom fitten we dit model opnieuw waarbij we de afstanden groeperen in intervallen van 50 m.

```{r, cache=TRUE}
veldleeuwerik_dist_2022_hr22_binned <- ds(data = veldleeuwerik_distance, key = "hr", 
        formula = ~sbp*jaar + openheid, adjustment = NULL, truncation = 300, 
        transect = "point", dht_group = FALSE, 
        cutpoints = c(0, 50, 100, 150, 200, 250, 300),
        convert_units = conversion_factor, region_table = region_table, 
        sample_table = sample_table, obs_table = obs_table)
```

De fit ziet er beter uit dan voordien.

```{r}
plot(veldleeuwerik_dist_2022_hr22_binned, pdf = TRUE, showpoints = FALSE)
```

We selecteren het intervalmodel met Hazard-rate sleutelfunctie waarbij de detectiekans afhankelijk is van sbp, jaar en openheid met sbp en jaar in interactie als finale model.

```{r}
veldleeuwerik_dist_2022_model <- veldleeuwerik_dist_2022_hr22_binned
veldleeuwerik_covars <- c("sbp", "jaar", "openheid")
```

## Resultaten {#resultaten-distance}

De detectiekansen en standard errors zijn verschillend per regio, jaar en openheid van het landschap:

```{r}
cbind(veldleeuwerik_dist_2022_model$ddf$data, 
      "p(z)" = predict(veldleeuwerik_dist_2022_model, 
                       se.fit = TRUE)$fitted, 
      "standard error" = predict(veldleeuwerik_dist_2022_model, 
                                 se.fit = TRUE)$se) %>%
  select(all_of(veldleeuwerik_covars), "p(z)", "standard error") %>%
  distinct() %>%
  arrange(!!!veldleeuwerik_covars) %>%
  kable()
```

De gemiddelde detectiekans $\hat{P}_a$ is gelijk aan `r round(veldleeuwerik_dist_2022_model$dht$individuals$average.p, digits = 3)`.
Deze kunnen we als volgt visualiseren:

```{r}
plot_detection_curve(veldleeuwerik_dist_2022_model, 
                     plot_average_fit = TRUE, n_breaks = 6)
```

```{r}
summary_veldleeuwerik_dist <- summary(veldleeuwerik_dist_2022_model)

summary_results_veldleeuwerik_dist <- bind_rows(
  summary_veldleeuwerik_dist$dht$individuals$D %>%
    mutate(variable = "density",
           type = "Aantal broedparen per 100 ha"),
  summary_veldleeuwerik_dist$dht$individuals$N %>%
    mutate(variable = "abundance",
           type = "Totaal aantal broedparen")
  ) %>%
  filter(Label != "Total") %>%
  separate(Label, into = c("regio", "jaar"), sep = " - ")
```

Per stratum (combinatie regio en jaar) krijgen we dan de abundanties:

```{r}
summary_results_veldleeuwerik_dist %>%
  filter(variable == "abundance") %>%
  select(regio, jaar, schatting = Estimate, se, lcl, ucl) %>%
  arrange(regio, jaar) %>%
  kable(digits = 3)
```

Densiteiten:

```{r}
summary_results_veldleeuwerik_dist %>%
  filter(variable == "density") %>%
  select(regio, jaar, schatting = Estimate, se, lcl, ucl) %>%
  arrange(regio, jaar) %>%
  kable(digits = 3)
```

We visualiseren de densiteit over de jaren per regio.

```{r}
summary_results_veldleeuwerik_dist %>%
  filter(variable == "density") %>%
  ggplot(aes(x = jaar, y = Estimate, colour = regio)) + 
    geom_point(size = 4) + 
    geom_errorbar(aes(ymin = lcl, ymax = ucl), width = 0.25) +
    scale_y_continuous(limits = c(0, NA)) +
    facet_wrap(~regio, scales = "free_y") +
    labs(x = "", y = "Aantal broedparen per 100 ha", 
         title = "Veldleeuwerik - densiteit") +
    theme(legend.position = "")
```

## Discussie {#discussie-distance}

@roodbergen2011 hadden voor de Veldleeuwerik gelijkaardige problemen om een passende detectiecurve te fitten.
Zij stellen dat dit kan worden veroorzaakt doordat vogels zich verplaatsen als reactie op de waarnemer of het afronden van afstanden door waarnemers.
Dit laatste is bij ons zeker niet het geval doordat waarnemers een punt aanduiden op de kaart via een app en niet manueel een afstand invoeren.
Het probleem ligt dus waarschijnlijk in het gedrag van de soort.
Veldleeuwerikken vliegen gemakkelijk op bij verstoring waardoor we minder waarnemingen zien op kleinere afstanden en dan weer een groter aantal zien rond ca.
75-100 m.
Bovendien is de soort nog gemakkelijk te horen op grotere afstand zonder exact de locatie te weten.
Hierdoor zien we opnieuw een stijging rond 250 m.
@roodbergen2011 fitten daarom voor deze soort een detectiecurve m.b.v. afstandsintervallen.
Wij groepeerden daarom de afstanden per 50 m.
Hoewel de fit er visueel beter uitzag, waren de densiteitsschattingen en hun onzekerheid quasi identiek aan de eerdere resultaten zonder groepering (resultaten niet getoond).

We kunnen deze resultaten vergelijken met andere technieken.
Het gemiddelde en het maximum aantal en broedparen over de telperiodes.
Opgeteld per jaar en per regio.
Omgerekend naar densiteit door te delen door de bezochte oppervlakte.
Voor het gemiddelde is ook met absensies rekening gehouden (maakt voor maximum niet uit).
De gemiddeldes liggen lager, terwijl de maxima goed overeenkomen met de resultaten van distance sampling.
@wiersma2021 gebruiken de maxima om de densiteiten te schatten.
Ze stellen dat dit minimumschattingen zijn omdat ze niet voor onvolledige trefkans hebben gecorrigeerd.
Wij doen dat wel via distance sampling, maar in het geval van de Veldleeuwerik zien we hier geen groot verschil tussen het gebruik van maxima of distance sampling.

In de volgende figuur zijn de gemiddeldes en maxima aangegeven door bar-plots en waarbij de resultaten van distance sampling erover zijn geplot.

```{r}
# Bereken aantal plots per regio per jaar
plots_per_regiojaar <- plots_per_jaar %>%
  mutate(Region.Label = paste(regio, jaar, sep = " - "))

# Oppervlakte telcirkels
cirkelopp <- pi * 300^2

distance_plot_df <- summary_results_veldleeuwerik_dist %>%
  filter(variable == "density") %>%
  mutate(jaar = as.integer(jaar))

veldleeuwerik_df %>%
  # Bepaal voor elke plot het gemiddeld aantal individuen en maximum over
  # de telperiodes per jaar
  group_by(plotnaam, jaar, periode_in_jaar) %>%
  mutate(totaal = sum(aantal)) %>%
  group_by(plotnaam, jaar) %>%
  mutate(gemiddelde = mean(totaal),
            maximum = max(totaal)) %>%
  ungroup() %>%
  select(-c(periode_in_jaar, aantal, totaal)) %>%
  distinct() %>%
  
  # Bereken dan het totaal aantal individuen over alle plots (som)
  group_by(Region.Label) %>%
  summarise(tot_gemiddelde = sum(gemiddelde),
            tot_max = sum(maximum)) %>% 
  
  # Deel door aantal plots om aantal broedkoppels per plot te krijgen
  full_join(plots_per_regiojaar, by = "Region.Label") %>%
  mutate(tot_gemiddelde_plots = (tot_gemiddelde / aantal_plots) / cirkelopp * 1e6,
         tot_max_plots = (tot_max / aantal_plots) / cirkelopp * 1e6) %>%
  pivot_longer(cols = c("tot_gemiddelde_plots", "tot_max_plots"), 
               names_to = "categorie", values_to = "Estimate") %>%
  
  # Visualiseer
  ggplot(aes(x = jaar, y = Estimate)) + 
    geom_bar(aes(fill = regio), stat = "identity") + 
    geom_point(data = distance_plot_df, aes(x = jaar, y = Estimate), size = 4) + 
    geom_errorbar(data = distance_plot_df, aes(ymin = lcl, ymax = ucl), 
                  width = 0.25) +
    labs(x = "", y = "Aantal broedparen Veldleeuwerik per 100 ha") +
    theme(legend.position = "") +
    facet_wrap(regio~categorie, labeller = labeller(
      categorie = c(
        "tot_gemiddelde_plots" = "Gemiddeld aantal broedparen per plot",
        "tot_max_plots" = "Maximum aantal broedparen per plot")
      ), scales = "free_y")
```

## Referenties
