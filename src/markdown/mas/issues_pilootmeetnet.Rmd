---
title: "Lijst issues met steekproef pilootmeetnet"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
renv::restore()
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE)
opts_knit$set(root.dir = here::here())
library(tidyverse)
library(sf)
```


# Inlezen data

We lezen de KML-file in. In de attributentabel staan issues waarmee we moeten rekening houden in volgende steekproeftrekkingen. Het inlezen van deze data is niet triviaal. Zie:  
https://github.com/r-spatial/sf/issues/499  
https://gis.stackexchange.com/questions/301336/extracting-non-spatial-data-from-imported-kml-file-using-r  

```{r}
# Create data path
data_path <- here("data", "mas")

# Source R function to read KML
source_path <- here("src", "R")
source(paste(source_path, "read_KML.R", sep = "/"))

# Read data
kml_file <- paste(data_path, "MAS punten 2022 per teller.kml", sep = "/")
issue_list_raw <- read_KML(kml_file) %>%
  st_drop_geometry()
```


# Hoe zien de data eruit?

```{r}
glimpse(issue_list_raw)
```

- name: tellerscode van de waarnemer
- beschrijving:
    - OK = punt kan geteld worden
    - andere tekstuele opmerking beschrijft waarom (beter) niet
- beslissing: omzetting van beschrijving naar concrete beslissingsboom
    - behouden: dit punt wordt geteld
    - vervangen door bestaand: een oud MAS punt (uit vorige programma) kan verdergezet worden omdat het centrum van het nieuw punt in de telcirkel van het oude MAS punt valt
    - vervangen door reserve: dit punt wordt vervangen door een resevepunt omdat het niet voldoet aan onze voorwaarden
    - dubbel: punt staat dubbel in de lijst
- vervanging_id: id van het punt waardoor het vervangen wordt. Dat reserve punt kan dan op zijn beurt ook nog vervangen worden (indien afgekeurd) door een ander reserve punt.
- rest van de kolommen zijn eigenschappen/klassen van dat punt


# Data voorbereiden

Hoe zijn de beslissingen verdeeld?

```{r}
issue_list_raw %>%
  count(beslissing) %>%
  kable()
```

De categorie 'vervanging, behouden' is nogal tegenstrijdig en onduidelijk.

```{r}
issue_list_raw %>%
  filter(beslissing == "vervanging, behouden") %>%
  select(c(Name, beschrijving, beslissing, vervanging_id, pointid)) %>%
  kable()
```

De beschrijvingen wijzen niet op belangrijke problemen. We zetten alles om door 'vervanging,' te verwijderen uit de categoriën. Ook veranderen we 'verplaatsen door bestaand' in 'vervangen door bestaand'.

```{r}
issue_list <- issue_list_raw %>%
  mutate(beslissing = gsub("vervanging, ", "", beslissing),
         beslissing = ifelse(beslissing == "verplaatsen door bestaand", 
                             "vervangen door bestaand", beslissing))

issue_list %>%
  count(beslissing) %>%
  kable()
```

Waar komen de ```NA``'s vandaan?

```{r}
issue_list %>%
  filter(is.na(beslissing)) %>%
  select(c(Name, beschrijving, beslissing, vervanging_id, pointid)) %>%
  kable()
```

Dit zijn allemaal problematische punten dus we zetten beslissing op 'vervangen door reserve'.

```{r}
issue_list <- issue_list %>%
  mutate(beslissing = ifelse(is.na(beslissing), "vervangen door reserve", 
                             beslissing))

issue_list %>%
  count(beslissing) %>%
  kable()
```

We zijn geïnteresseerd in de redenen voor 'vervangen door reserve'.

```{r}
issues <- issue_list %>%
  filter(beslissing == "vervangen door reserve")
```


# Analyse issues telpunten

In totaal zijn er `r nrow(issues)` problematische telpunten.

van specifieke termen naar algemene termen (eerst veel info en later weinig)

```{r}
# Patroon ontoegankelijke plots
pattern1 <- "E40 en sporen|E40|snelweg|(fiets)?pad|priv(e|é)|verboden|grote baan"
pattern2 <- "beek|langs water|serres|((O|o)n)?toegankelijk|[[:alpha:]]*bereikbaar"
# Patroon obstructies zichtbaarheid
pattern3 <- "holle weg|Holleweg|talud|haag|boomgaard|bos|put|ingesloten"
# Patroon overlap
pattern4 <- "overlap|bufferstrook"
# Restpatronen
pattern5 <- "zicht[[:alpha:]]*|visibiliteit"
pattern6 <- "niet super"

issue_cat <- issues %>%
  select(beschrijving) %>%
  mutate(
    match = case_when(
      str_detect(beschrijving, paste(pattern1, pattern2, sep = "|")) ~ 
        str_extract(beschrijving, paste(pattern1, pattern2, sep = "|")),
      str_detect(beschrijving, pattern3) ~ 
        str_extract(beschrijving, pattern3),
      str_detect(beschrijving, pattern4) ~ 
        str_extract(beschrijving, pattern4),
      str_detect(beschrijving, pattern5) ~ 
        str_extract(beschrijving, pattern5),
      str_detect(beschrijving, pattern6) ~ 
        str_extract(beschrijving, pattern6)
      ),
    match = recode(match, "Holleweg" = "holle weg"),
    reden = case_when(
      match %in% c("E40", "E40 en sporen", "prive", "privé", "ontoegankelijk", 
                   "verboden", "grote baan", "onbereikbaar", "bereikbaar", 
                   "Ontoegankelijk", "toegankelijk", "snelweg", "fietspad", 
                   "pad", "beek", "langs water", "serres") ~ 
        "ontoegankelijk",
      match %in% c("holle weg", "talud", "haag", "ingesloten", 
                   "boomgaard", "bos", "put") ~ 
        "obstructie zichtbaarheid",
      match %in% c("overlap", "bufferstrook") ~ 
        "overlap",
      match %in% c("zicht", "zichtbaar", "zichtbaarheid", "visibiliteit") ~ 
        "zichtbaarheid",
      match == "niet super" ~ 
        "niet super")
    )
```


```{r}
for (cat in unique(issue_cat$reden)) {
  print(
  if (!is.na(cat)) {
  issue_cat %>%
    filter(reden == cat) %>%
    pivot_wider(id_cols = "match",
                names_from = "reden",
                values_from = "reden",
                values_fn = list(reden = length)) %>%
    arrange(match) %>%
    kable()
  } else {
    issue_cat %>%
      filter(is.na(reden)) %>%
      group_by(reden) %>%
      mutate(aantal_NA = n()) %>%
      kable()
  })
}
```


