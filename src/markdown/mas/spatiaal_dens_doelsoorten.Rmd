---
title: "Spatiaal model densiteit doelsoorten"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# renv
renv::restore()

# Set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE)
opts_knit$set(root.dir = here())
```

```{r}
# Packages
library(tidyverse)
library(INBOtheme)
theme_set(theme_inbo(base_size = 12, transparent = TRUE))
library(sf)
library(brms)
library(targets)
library(metR)
library(mapview)

# Conflicting packages
conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::select)
conflicted::conflicts_prefer(brms::ar)
conflicted::conflicts_prefer(stats::lag)

# Paths
model_path <- here("src", "markdown", "mas", "spatiale_modellen")
dir.create(model_path, showWarnings = FALSE)
```

```{r, results="hide"}
# targets
targets_store <- here("src", "targets", "mas_steekproef_pilootfase", "_targets")

new_tar_vector <- function(value, objects) {
    out <- do.call(vctrs::vec_rbind, objects)
    if (any(sapply(out, inherits, what = "sfc"))) {
      sf::st_as_sf(out)
    } else {out}
}
try(assignInNamespace(
  "value_produce_aggregate.tar_vector",
  new_tar_vector,
  ns = "targets"))
```

# Inlezen data

```{r}
data_path <- here("data", "processed")
mas_data_df <- read_csv(here(data_path, "MAS_data_full_2018_2023.csv"))
```

```{r}
design_df <- mas_data_df %>%
  distinct(plotnaam, regio, periode_in_jaar, jaar,
           openheid = openheid_klasse_300, sbp,
           x_plot, y_plot)

mas_data_sf <- st_as_sf(mas_data_df, coords = c("x_lambert", "y_lambert"), 
                        crs = 31370)
```

# Data selectie en preparatie

We selecteren de data van 2022-2023 in de Oostelijke leemstreek in OL en HOL met broedcode > 0.
We sommeren de aantallen per soort, telcirkel, telperiode en jaar. We voegen ook afwezigheden (nullen) toe.
3 doelsoorten zijn geselecteerd: (1) Veldleeuwerik, (2) Gele Kwikstaart en (3) Geelgors.
We voegen de detectiekansen van de distance sampling modellen toe aan de dataframes.

```{r}
create_species_df <- function(species, data = mas_data_df, design = design_df) {
  # Presence data
  presences_df <- data %>%
    filter(naam == species,
           jaar %in% 2022:2023,
           regio == "Oostelijke leemstreek",
           wrntype > 0) %>%
    group_by(plotnaam, periode_in_jaar, jaar) %>%
    summarise(aantal = sum(aantal),
              .groups = "drop")
  
  # Add absences
  out_df <- design %>%
    filter(jaar %in% 2022:2023,
           regio == "Oostelijke leemstreek") %>%
    left_join(presences_df, 
              by = join_by(plotnaam, periode_in_jaar, jaar)) %>%
    replace(is.na(.), 0) %>%
    arrange(plotnaam, periode_in_jaar, jaar) %>%
    mutate(naam = species) %>%
    select(plotnaam, naam, aantal, periode_in_jaar, jaar, openheid, sbp,
           x_plot, y_plot) %>%
    filter(openheid %in% c("OL", "HOL"))
  
  return(out_df)
}
```

```{r}
dsmodels_2022 <- readRDS(
  file.path("src", "markdown", "mas", "distance_models",
            "models_2022.rds"))
dsmodels_2023 <- readRDS(
  file.path("src", "markdown", "mas", "distance_models",
            "models_2023.rds"))
```

```{r}
get_detection_prob <- function(species) {
  ds_2022 <- dsmodels_2022[gsub("\\s", "", species)][[1]]
  ds_2023 <- dsmodels_2023[gsub("\\s", "", species)][[1]]
  
  covars <- c("regio", "sbp", "openheid", "jaar")
  out <- cbind(ds_2022$ddf$data,
        "detectiekans" = predict(ds_2022)$fitted) %>%
    mutate(jaar = 2022) %>%
    bind_rows(
      cbind(ds_2023$ddf$data,
        "detectiekans" = predict(ds_2023)$fitted) %>%
      mutate(jaar = 2023)
    ) %>%
    select(all_of(covars), "detectiekans") %>%
    distinct() %>%
    filter(regio == "Oostelijke leemstreek") %>%
    select(-regio) %>%
    arrange(jaar, openheid)
  
  return(out)
}
```

```{r}
doelsoorten <- c("Veldleeuwerik", "Gele Kwikstaart", "Geelgors")
for (soort in doelsoorten) {
  df_soort <- create_species_df(soort)
  df_det_prob <- get_detection_prob(soort)
  
  merged_df <- df_soort %>%
    full_join(df_det_prob, by = join_by(jaar, openheid, sbp)) %>%
    mutate(cirkelopp = pi * 300^2,
           ha_100 = 10^6,
           offset = (detectiekans * cirkelopp) / ha_100)
  
  name <- paste(gsub("\\s", "", tolower(soort)), "df", sep = "_")
  assign(name, merged_df)
}
```

# Veldleeuwerik
## Model fitten

We fitten een Poisson model met $Y_{j,t}$ het aantal individuen in telcirkel $j$ in telperiode $t$

$$
Y_{j,t} \sim Pois(\lambda_{j,t})
$$

met

$$
\ln(\lambda_{j,t}) = \beta_0 + f(x_j, y_j) + b_{0,j} + b_{1,j:t} + \ln(p_s) + \ln\left(\frac{A_{telcirkel}}{10^6\ \text{m}^2/100\ \text{ha}}\right)
$$

Waarbij $p_s$ de detectiekans van de soort is in stratum $s$ (per regio, jaar, openheid landschap, binnen of buiten sbp) en $A_{telcirkel}$ de oppervlakte van een telcirkel $A_{telcirkel} = \pi * 300^2 =$ `r pi * 300^2` m².
We kunnen deze 'offset' termen samen nemen.

$$
\ln(\lambda_{j,t}) = \beta_0 + f(x_j, y_j) + b_{0,j} + b_{1,j:t} + \ln(\text{offset})
$$

zodat

$$
\ln\left(\frac{\lambda_{j,t}}{\text{offset}}\right) = \beta_0 + f(x_j, y_j) + b_{0,j} + b_{1,j:t}
$$

Waarbij $f()$ de default smoothing function is van de `s()` functie en $x_j$, $y_j$ resp. de X- en Y- coordinaten van telpunt $j$.
$\text{offset}$ is gelijk aan de detectiekans vermenigvuldigd met een factor om het aantal individuen per telcirkel om te zetten naar aantal individuen per 100 ha.
Zo krijgen we een model voor het gemiddeld aantal broedparen per 100 ha waarbij we corrigeren voor detectiekans.

```{r}
# MCMC parameters
nchains <- 3           # number of chains
niter <- 2500          # number of iterations (incl. burn-in)
burnin <- 500          # number of initial samples to discard (burn-in)
nparallel <- nchains   # number of cores used for parallel computing
thinning <- 1
```

```{r}
fit_veldleeuwerik <- brm(
  bf(aantal ~ s(x_plot, y_plot) + (1|plotnaam) + (1|plotnaam:periode_in_jaar) +
       offset(log(offset))),
  data = veldleeuwerik_df,
  family = poisson(),
  chains = nchains, 
  warmup = burnin, 
  iter = niter,
  cores = nparallel,
  thin = thinning,
  backend = "cmdstanr",
  seed = 123,
  file = here(model_path, "fit_veldleeuwerik"),
  file_refit = "on_change")
```

## MCMC convergentie

MCMC convergentie is goed.

```{r}
plot(fit_veldleeuwerik, ask = FALSE)
```

## Model fit

Model fit is goed genoeg.

```{r}
pp_check(fit_veldleeuwerik, type = "bars", ndraws = 100)
```

## Resultaten

We lezen het steekproefkader in.

```{r}
perimeter <- tar_read(perimeters_data, store = targets_store)
perimeter_ol <- perimeter %>%
  filter(Naam == "Oostelijke leemstreek")

steekproefkader <- tar_read(steekproefkader_finaal, store = targets_store)
steekproefkader_buf <- steekproefkader %>%
  filter(Naam == "Oostelijke leemstreek",
         openheid_klasse %in% c("OL", "HOL")) %>%
  st_buffer(300)
```

We maken een grid met cellen van dezelfde oppervlakte als de telcirkels en leggen deze over het steekproefkader (= telpunten steekproefkader met buffer van 300 m).
Voor de centroïde van elke grid cell maken we een predictie o.b.v. het model.

```{r}
# Maak grid over bounding box steekproefkader
grid_total <- st_make_grid(steekproefkader_buf,
                           cellsize = units::set_units(300*300*pi, "m^2"),
                           square = TRUE) %>%
  as_tibble() %>%
  rownames_to_column(var = "id") %>%
  st_as_sf(crs = 31370)

# Selecteer enkel gridcellen die overlappen met steekproefkader
ids <- st_intersection(grid_total, steekproefkader_buf) %>%
  pull(id)

grid <- grid_total %>%
  filter(id %in% ids)

new_df <- grid %>%
  st_centroid() %>%
  as_tibble() %>%
  mutate(x_plot = st_coordinates(.data$geometry)[, 1],
         y_plot = st_coordinates(.data$geometry)[, 2])

# Maak predicties op basis van model
pred_veldleeuwerik <- fitted(fit_veldleeuwerik, new_df, robust = TRUE,
                             re_formula = NA, offset = FALSE)
```

We visualiseren de gemiddelde densiteiten (mediaan) via `geom_tile()`.

```{r}
plot_veldleeuwerik <- new_df %>%
  bind_cols(pred_veldleeuwerik) %>%
  select(id, x_plot, y_plot, Estimate, Q2.5, Q97.5) %>%
  mutate(across(c(x_plot, y_plot), ~ round(.x, digits = 4)),
         rel_fout = (Q97.5 - Q2.5) / (2 * Estimate))

plot_veldleeuwerik %>%
  ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = Estimate)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 5, 10, 15, 20),
                         limits = c(0, 20)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Aantal broedparen\nper 100 ha",
         title = "Veldleeuwerik") +
    theme(legend.position = "bottom")
```

We kunnen contourlijnen toevoegen om de figuur begrijpbaarder te maken.
We voegen contouren toe per 1, 3, 5 ... broedparen per 100 ha.

```{r}
p_veldleeuwerik1 <- plot_veldleeuwerik %>%
  ggplot() +
  geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
          linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = Estimate)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 5, 10, 15, 20),
                         limits = c(0, 20)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Aantal broedparen\nper 100 ha") +
    theme(legend.position = "bottom") +
    geom_contour2(
      aes(x = x_plot, y = y_plot, z = Estimate, label = after_stat(level)),
      breaks = seq(1, 21, 2), skip = 1,
      label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_veldleeuwerik1
```

We visualiseren ook de spatiale verdeling van de onzekerheid.
Dit doen we door het 95 % credible interval toe te voegen.

```{r}
p_veldleeuwerik2 <- plot_veldleeuwerik %>%
  rename(mediaan = Estimate) %>%
  pivot_longer(cols = c("mediaan",  "Q2.5", "Q97.5"), names_to = "statistiek",
               values_to = "waarde") %>%
  mutate(statistiek = factor(statistiek, levels = c("Q2.5", "mediaan", "Q97.5"))) %>%
  ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = waarde)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 6, 12, 18, 24, 30, 36),
                         limits = c(0, 36)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "",
         fill = "Aantal broedparen\nper 100 ha") +
    theme(legend.position = "right") +
    facet_wrap(~statistiek, ncol = 1) +
    geom_contour2(
        aes(x = x_plot, y = y_plot, z = waarde, label = after_stat(level)),
        breaks = seq(1, 36, 2), skip = 1,
        label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_veldleeuwerik2
```

```{r}
p_veldleeuwerik3 <- plot_veldleeuwerik %>%
    ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = rel_fout)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 0.4, 0.8, 1.2, 1.6),
                         limits = c(0, 1.6)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Rel. fout aantal broed-\nparen per 100 ha") +
    theme(legend.position = "bottom") +
    geom_contour2(
        aes(x = x_plot, y = y_plot, z = rel_fout, label = after_stat(level)),
        breaks = seq(0, 1.6, 0.1), skip = 1,
        label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_veldleeuwerik3
```

```{r}
dir.create(here("media", "spatiale_densiteiten"), showWarnings = FALSE,
           recursive = TRUE)
ggsave(here("media", "spatiale_densiteiten", "veldleeuwerik_dens_ol1.png"),
       p_veldleeuwerik1,
       dpi = 300,
       width = 8,
       height = 4)
ggsave(here("media", "spatiale_densiteiten", "veldleeuwerik_dens_ol1.pdf"),
       p_veldleeuwerik1,
       dpi = 300,
       width = 8,
       height = 4)

ggsave(here("media", "spatiale_densiteiten", "veldleeuwerik_dens_ol2.png"),
       p_veldleeuwerik2,
       dpi = 300,
       width = 10,
       height = 8)
ggsave(here("media", "spatiale_densiteiten", "veldleeuwerik_dens_ol2.pdf"),
       p_veldleeuwerik2,
       dpi = 300,
       width = 10,
       height = 8)

ggsave(here("media", "spatiale_densiteiten", "veldleeuwerik_dens_ol3.png"),
       p_veldleeuwerik3,
       dpi = 300,
       width = 8,
       height = 4)
ggsave(here("media", "spatiale_densiteiten", "veldleeuwerik_dens_ol3.pdf"),
       p_veldleeuwerik3,
       dpi = 300,
       width = 8,
       height = 4)
```

## Interactieve kaarten

We maken een interactieve kaart kaart voor Veldleeuwerik.

```{r}
grid_veldleeuwerik <- grid %>%
  bind_cols(pred_veldleeuwerik) %>%
  select(id, Estimate, Q2.5, Q97.5, geometry) %>%
  mutate(Estimate = round(Estimate, 3),
         rel_fout = (Q97.5 - Q2.5) / (2 * Estimate)) %>%
  st_as_sf(sf_column_name = "geometry", crs = 31370)
```

```{r}
m1 <- mapview(grid_veldleeuwerik,
        zcol = "Estimate",
        alpha = 0,
        layer.name = "Mediaan",
        map.types = "OpenStreetMap")

m2 <- mapview(grid_veldleeuwerik,
              zcol = "Q2.5",
        alpha = 0,
        layer.name = "Q2.5",
        map.types = "OpenStreetMap")

m3 <- mapview(grid_veldleeuwerik,
        zcol = "Q97.5",
        alpha = 0,
        layer.name = "Q97.5",
        map.types = "OpenStreetMap")

m4 <- mapview(grid_veldleeuwerik,
        zcol = "Q97.5",
        alpha = 0,
        layer.name = "Rel. foutenmarge",
        map.types = "OpenStreetMap")

leafsync::sync(
  leaflet::addControl(m1@map, "Aantal broedparen Veldleeuwerik per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m2@map, "Aantal broedparen Veldleeuwerik per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m3@map, "Aantal broedparen Veldleeuwerik per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m4@map, "Rel. fout Veldleeuwerik per 100 ha",
                      position = "bottomleft"))
```


# Gele Kwikstaart
## Model fitten

We fitten hetzelfde model voor Gele kwikstaart.

```{r}
fit_gelekwikstaart <- brm(
  bf(aantal ~ s(x_plot, y_plot) + (1|plotnaam) + (1|plotnaam:periode_in_jaar) +
       offset(log(offset))),
  data = gelekwikstaart_df,
  family = poisson(),
  chains = nchains, 
  warmup = burnin, 
  iter = niter,
  cores = nparallel,
  thin = thinning,
  backend = "cmdstanr",
  seed = 123,
  file = here(model_path, "fit_gelekwikstaart"),
  file_refit = "on_change")
```

## MCMC convergentie

MCMC convergentie is goed.

```{r}
plot(fit_gelekwikstaart, ask = FALSE)
```

## Model fit

Model fit is goed genoeg.

```{r}
pp_check(fit_gelekwikstaart, type = "bars", ndraws = 100)
```

## Resultaten

Zoals voordien maken we voor de centroïde van elke grid cell een predictie o.b.v. het model.

```{r}
pred_gelekwikstaart <- fitted(fit_gelekwikstaart, new_df, robust = TRUE,
                              re_formula = NA, offset = FALSE)
```

We visualiseren de gemiddelde densiteiten (mediaan) via `geom_tile()`.

```{r}
plot_gelekwikstaart <- new_df %>%
  bind_cols(pred_gelekwikstaart) %>%
  select(id, x_plot, y_plot, Estimate, Q2.5, Q97.5) %>%
  mutate(across(c(x_plot, y_plot), ~ round(.x, digits = 4)),
         rel_fout = (Q97.5 - Q2.5) / (2 * Estimate))

plot_gelekwikstaart %>%
  ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = Estimate)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 4, 8, 12, 16),
                         limits = c(0, 16)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Aantal broedparen\nper 100 ha",
         title = "Gele kwikstaart") +
    theme(legend.position = "bottom")
```

We kunnen contourlijnen toevoegen om de figuur begrijpbaarder te maken.
We voegen contouren toe per broedpaar per 100 ha.

```{r}
p_gelekwikstaart1 <- plot_gelekwikstaart %>%
  ggplot() +
  geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
          linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = Estimate)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 4, 8, 12, 16),
                         limits = c(0, 16)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Aantal broedparen\nper 100 ha") +
    theme(legend.position = "bottom") +
    geom_contour2(
      aes(x = x_plot, y = y_plot, z = Estimate, label = after_stat(level)),
      breaks = seq(1, 16, 1), skip = 1,
      label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_gelekwikstaart1
```

We visualiseren ook de spatiale verdeling van de onzekerheid. Dit doen we door het 95 % credible interval toe te voegen.

```{r}
p_gelekwikstaart2 <- plot_gelekwikstaart %>%
  rename(mediaan = Estimate) %>%
  pivot_longer(cols = c("mediaan",  "Q2.5", "Q97.5"), names_to = "statistiek",
               values_to = "waarde") %>%
  mutate(statistiek = factor(statistiek, levels = c("Q2.5", "mediaan", "Q97.5"))) %>%
  ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = waarde)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 4, 8, 12, 16, 20, 24),
                         limits = c(0, 24)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "",
         fill = "Aantal broedparen\nper 100 ha") +
    theme(legend.position = "right") +
    facet_wrap(~statistiek, ncol = 1) +
    geom_contour2(
        aes(x = x_plot, y = y_plot, z = waarde, label = after_stat(level)),
        breaks = seq(1, 24, 2), skip = 1,
        label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_gelekwikstaart2
```

```{r}
dir.create(here("media", "spatiale_densiteiten"), showWarnings = FALSE,
           recursive = TRUE)
ggsave(here("media", "spatiale_densiteiten", "gelekwikstaart_dens_ol1.png"),
       p_gelekwikstaart1,
       dpi = 300,
       width = 8,
       height = 4)
ggsave(here("media", "spatiale_densiteiten", "gelekwikstaart_dens_ol1.pdf"),
       p_gelekwikstaart1,
       dpi = 300,
       width = 8,
       height = 4)

ggsave(here("media", "spatiale_densiteiten", "gelekwikstaart_dens_ol2.png"),
       p_gelekwikstaart2,
       dpi = 300,
       width = 10,
       height = 8)
ggsave(here("media", "spatiale_densiteiten", "gelekwikstaart_dens_ol2.pdf"),
       p_gelekwikstaart2,
       dpi = 300,
       width = 10,
       height = 8)
```

## Interactieve kaarten

We maken een interactieve kaart kaart voor Gele kwikstaart.

```{r}
grid_gelekwikstaart <- grid %>%
  bind_cols(pred_gelekwikstaart) %>%
  select(id, Estimate, Q2.5, Q97.5, geometry) %>%
  mutate(Estimate = round(Estimate, 3),
         rel_fout = (Q97.5 - Q2.5) / (2 * Estimate)) %>%
  st_as_sf(sf_column_name = "geometry", crs = 31370)
```

```{r}
m1 <- mapview(grid_gelekwikstaart,
        zcol = "Estimate",
        alpha = 0,
        layer.name = "Mediaan",
        map.types = "OpenStreetMap")

m2 <- mapview(grid_gelekwikstaart,
              zcol = "Q2.5",
        alpha = 0,
        layer.name = "Q2.5",
        map.types = "OpenStreetMap")

m3 <- mapview(grid_gelekwikstaart,
        zcol = "Q97.5",
        alpha = 0,
        layer.name = "Q97.5",
        map.types = "OpenStreetMap")

m4 <- mapview(grid_gelekwikstaart,
        zcol = "Q97.5",
        alpha = 0,
        layer.name = "Rel. foutenmarge",
        map.types = "OpenStreetMap")

leafsync::sync(
  leaflet::addControl(m1@map, "Aantal broedparen Gele kwikstaart per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m2@map, "Aantal broedparen Gele kwikstaart per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m3@map, "Aantal broedparen Gele kwikstaart per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m4@map, "Rel. fout Gele kwikstaart per 100 ha",
                      position = "bottomleft"))
```


# Geelgors
## Model fitten

We fitten hetzelfde model voor Geelgors.

```{r}
fit_geelgors <- brm(
  bf(aantal ~ s(x_plot, y_plot) + (1|plotnaam) + (1|plotnaam:periode_in_jaar) +
       offset(log(offset))),
  data = geelgors_df,
  family = poisson(),
  chains = nchains, 
  warmup = burnin, 
  iter = niter,
  cores = nparallel,
  thin = thinning,
  backend = "cmdstanr",
  seed = 123,
  file = here(model_path, "fit_geelgors"),
  file_refit = "on_change")
```

## MCMC convergentie

MCMC convergentie is goed.

```{r}
plot(fit_geelgors, ask = FALSE)
```

## Model fit

Model fit is goed genoeg.

```{r}
pp_check(fit_geelgors, type = "bars", ndraws = 100)
```

## Resultaten

Zoals voordien maken we voor de centroïde van elke grid cell een predictie o.b.v. het model.

```{r}
pred_geelgors <- fitted(fit_geelgors, new_df, robust = TRUE,
                        re_formula = NA, offset = FALSE)
```

We visualiseren de gemiddelde densiteiten (mediaan) via `geom_tile()`.

```{r}
plot_geelgors <- new_df %>%
  bind_cols(pred_geelgors) %>%
  select(id, x_plot, y_plot, Estimate, Q2.5, Q97.5) %>%
  mutate(across(c(x_plot, y_plot), ~ round(.x, digits = 4)),
         rel_fout = (Q97.5 - Q2.5) / (2 * Estimate))

plot_geelgors %>%
  ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = Estimate)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 3, 6, 9, 12),
                         limits = c(0, 12)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Aantal broedparen\nper 100 ha",
         title = "Geelgors") +
    theme(legend.position = "bottom")

```

We kunnen contourlijnen toevoegen om de figuur begrijpbaarder te maken.
We voegen contouren toe per broedpaar per 100 ha.

```{r}
p_geelgors1 <- plot_geelgors %>%
  ggplot() +
  geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
          linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = Estimate)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 3, 6, 9, 12),
                         limits = c(0, 12)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "", fill = "Aantal broedparen\nper 100 ha",
       title = "Geelgors") +
    theme(legend.position = "bottom") +
    geom_contour2(
      aes(x = x_plot, y = y_plot, z = Estimate, label = after_stat(level)),
      breaks = seq(1, 12, 1), skip = 1,
      label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_geelgors1
```

We visualiseren ook de spatiale verdeling van de onzekerheid. Dit doen we door het 95 % credible interval toe te voegen.

```{r}
p_geelgors2 <- plot_geelgors %>%
  rename(mediaan = Estimate) %>%
  pivot_longer(cols = c("mediaan",  "Q2.5", "Q97.5"), names_to = "statistiek",
               values_to = "waarde") %>%
  mutate(statistiek = factor(statistiek, levels = c("Q2.5", "mediaan", "Q97.5"))) %>%
  ggplot() +
    geom_sf(data = perimeter_ol, fill = "lightgrey", colour = "darkgrey",
            linewidth = 1) +
    geom_tile(aes(x = x_plot, y = y_plot, fill = waarde)) +
    scale_fill_gradientn(colours = rainbow(5),
                         breaks = c(0, 5, 10, 15, 20, 25, 30),
                         limits = c(0, 30)) +
    coord_sf(crs = 31370) +
    labs(x = "", y = "",
         fill = "Aantal broedparen\nper 100 ha") +
    theme(legend.position = "right") +
    facet_wrap(~statistiek, ncol = 1) +
    geom_contour2(
        aes(x = x_plot, y = y_plot, z = waarde, label = after_stat(level)),
        breaks = seq(1, 30, 2), skip = 1,
        label.placer = label_placer_fraction(frac = 0.5, rot_adjuster = 0))
p_geelgors2
```

```{r}
dir.create(here("media", "spatiale_densiteiten"), showWarnings = FALSE,
           recursive = TRUE)
ggsave(here("media", "spatiale_densiteiten", "geelgors_dens_ol1.png"),
       p_geelgors1,
       dpi = 300,
       width = 8,
       height = 4)
ggsave(here("media", "spatiale_densiteiten", "geelgors_dens_ol1.pdf"),
       p_geelgors1,
       dpi = 300,
       width = 8,
       height = 4)

ggsave(here("media", "spatiale_densiteiten", "geelgors_dens_ol2.png"),
       p_geelgors2,
       dpi = 300,
       width = 10,
       height = 8)
ggsave(here("media", "spatiale_densiteiten", "geelgors_dens_ol2.pdf"),
       p_geelgors2,
       dpi = 300,
       width = 10,
       height = 8)
```

## Interactieve kaarten

We maken een interactieve kaart kaart voor Geelgors.

```{r}
grid_geelgors <- grid %>%
  bind_cols(pred_geelgors) %>%
  select(id, Estimate, Q2.5, Q97.5, geometry) %>%
  mutate(Estimate = round(Estimate, 3),
         rel_fout = (Q97.5 - Q2.5) / (2 * Estimate)) %>%
  st_as_sf(sf_column_name = "geometry", crs = 31370)
```

```{r}
m1 <- mapview(grid_geelgors,
        zcol = "Estimate",
        alpha = 0,
        layer.name = "Mediaan",
        map.types = "OpenStreetMap")

m2 <- mapview(grid_geelgors,
              zcol = "Q2.5",
        alpha = 0,
        layer.name = "Q2.5",
        map.types = "OpenStreetMap")

m3 <- mapview(grid_geelgors,
        zcol = "Q97.5",
        alpha = 0,
        layer.name = "Q97.5",
        map.types = "OpenStreetMap")

m4 <- mapview(grid_geelgors,
        zcol = "Q97.5",
        alpha = 0,
        layer.name = "Rel. foutenmarge",
        map.types = "OpenStreetMap")

leafsync::sync(
  leaflet::addControl(m1@map, "Aantal broedparen Geelgors per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m2@map, "Aantal broedparen Geelgors per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m3@map, "Aantal broedparen Geelgors per 100 ha",
                      position = "bottomleft"),
  leaflet::addControl(m4@map, "Rel. fout Geelgors per 100 ha",
                      position = "bottomleft"))
```


# Discussie

Er zijn een aantal factoren die de methode kunnen verbeteren zoals de keuze voor de smoothing function $f()$.
Indien we subgebieden willen afbakenen, kunnen we gridcellen clusteren en daarna de predictie van de cluster vergelijken met een vooraf afgesproken waarde (bv. is het aantal broedparen per 100 ha significant meer dan 10?).
Hierbij moeten we een een methode vinden waarbij we op correcte wijze de onzekerheid berekenen op clusterniveau.
Een eerste mogelijkheid is om een variogram op te stellen o.b.v. de fitted values om een idee te krijgen van spatiale autocorrelatie.
Deze info kan dan gebruikt worden om de onzekerheid op clusterniveau te bepalen.
Een tweede mogelijkheid is om andere methodes en R packages te bekijken die dergelijke berekeningen incorporeren.
Deze mogelijkheden zullen in een later stadium onderzocht worden.
