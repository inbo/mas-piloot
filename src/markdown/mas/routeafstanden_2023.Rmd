---
title: "Routeafstanden veldwerk 2023"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
renv::restore()

# set up
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  out.width = "100%",
  options(scipen = 999))
opts_knit$set(root.dir = here::here())

# packages
library(tidyverse)
library(sf)
library(mapview)
library(osrm)
```


# Telpunten

We lezen de telpunten in van de pilootstudie van 2022 en de nieuwe steekproef in de zandleemstreek en de westelijke leemstreek. Van de nieuwe steekproef nemen we de eerste 50 punten (niet de reserve batch) en geen gerecupereerde punten (die zitten toch al in de dataset van de pilootstudie).

```{r}
# pilootstudie
piloot_punten <- read_csv(here(
    "data",
    "processed",
    "steekproef_piloot_avimap.csv")) %>%
  select(plotnaam = definitief_punt,
         regio,
         stratum,
         X, Y) %>%
  mutate(openheid_klasse = ifelse(grepl("HOL", stratum), "HOL", "OL"),
         sbp = ifelse(grepl("binnen", stratum), "binnen", "buiten"),
         stratum = gsub("L\\s{1}", "L\\\n", stratum),
         jaar = 2022L) %>%
  select(-c(stratum, sbp)) %>%
  st_as_sf(coords = c("X", "Y"), crs = 31370) %>%
  select(plotnaam, regio)

# zandleemstreek
zandleem_punten <- st_read(file.path(
    "data",
    "processed",
    "steekproef_zandleemstreek_telpunten.geojson")) %>%
  filter(batch == "eerste set",
         startsWith(pointid, "Zn")) %>%
  select(plotnaam = pointid, regio = Naam)

# westelijke leemstreek
leem_punten <- st_read(file.path(
    "data",
    "processed",
    "steekproef_leemstreek_telpunten.geojson")) %>%
  filter(batch == "eerste set") %>%
  mutate(Naam = "Westelijke leemstreek") %>%
  select(plotnaam = pointid, regio = Naam)
```

```{r}
punten_totaal <- bind_rows(
  piloot_punten,
  zandleem_punten,
  leem_punten
)

ggplot() +
  geom_sf(data = punten_totaal, aes(colour = regio)) +
  theme(legend.position = "bottom")
```


# Test osrm package voor routeberekening 

We testen de functie `osrmTrip()` van de **osrm** package op de eerste 8 punten vanuit Roeselare.

```{r}
roeselare <- tibble(plotnaam = NA, regio = NA, 
                    lat = 50.945005, 
                    long = 3.126043) %>%
  st_as_sf(coords = c("long", "lat"), crs = st_crs(4326)) %>%
  st_transform(31370)

trips <- osrmTrip(loc = bind_rows(roeselare, head(punten_totaal, 8)))

mapview(trips[[1]]$trip) + 
  mapview(head(punten_totaal))
```

De kortste route wordt berekend. Deze bedraagt `r trips[[1]]$summary$distance` km.


# Clustering van telpunten

We clusteren de punten. Omdat de densiteit van de punten sterk verschilt tussen de pilootstudie en de nieuwe punten, moeten we de berekeningen opsplitsen.

- De Moeren
- Zandleemstreek en Westelijke leemstreek
- Oostelijke leemstreek

We clusteren de punten in groepen zodat elke groep 8 punten kan bevatten. Het is echter niet vast te leggen hoeveel punten in elke groep zitten, zodat de groottes sterk uiteenlopen. Als er een punt alleen in een groep zit, plaatsen we dit punt in de groep van het dichtstbijzijnde punt.

```{r}
# The euclidian distance matrix
mtx_distance_dm <- st_distance(punten_totaal %>% filter(regio == "De Moeren"), 
                            punten_totaal %>% filter(regio == "De Moeren"))

# Cluster
clustering_dm <- hclust(dist(mtx_distance_dm), method = "mcquitty")

clusters_dm <- punten_totaal %>% 
  filter(regio == "De Moeren") %>%
  mutate(groep = paste(regio,
    cutree(clustering_dm, k = nrow(mtx_distance_dm) %/% 8))) %>%
  group_by(groep) %>%
  mutate(n = n()) %>%
  ungroup()

# Visualiseer
mapview(clusters_dm, zcol = "groep")
```

De gemiddelde groepgrootte in De Moeren is `r clusters_dm$groep %>% table() %>% mean()`.

```{r}
# The euclidian distance matrix
mtx_distance_ol <- st_distance(punten_totaal %>% 
                                 filter(regio == "Oostelijke leemstreek"), 
                               punten_totaal %>% 
                                 filter(regio == "Oostelijke leemstreek"))

# Cluster
clustering_ol <- hclust(dist(mtx_distance_ol), method = "mcquitty")

clusters_ol1 <- punten_totaal %>% 
  filter(regio == "Oostelijke leemstreek") %>%
  mutate(groep = cutree(clustering_ol, k = nrow(mtx_distance_ol) %/% 8)) %>%
  group_by(groep) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  mutate(groep = paste(regio, groep))
clusters_ol1 <- clusters_ol1 %>%
  mutate(dist = st_distance(geometry, clusters_ol1 %>% filter(n == 1)))

# Herbereken solo punt
min_dist <- clusters_ol1 %>% 
  filter(n != 1) %>% 
  arrange(dist) %>%
  head(1) %>%
  pull(groep)

group_n <- clusters_ol1 %>% 
  filter(groep == min_dist) %>% 
  pull(n) %>% 
  unique()

clusters_ol <- clusters_ol1 %>%
  mutate(groep = ifelse(n == 1, min_dist, groep),
         n = ifelse(groep == min_dist, group_n + 1, n))

# Visualiseer
mapview(clusters_ol, zcol = "groep")
```

De gemiddelde groepgrootte in Oostelijke leemstreek is `r clusters_ol$groep %>% table() %>% mean()`.

```{r}
#The euclidian distance matrix:
mtx_distance_2023 <- st_distance(punten_totaal %>% 
                                   filter(regio %in% c("Westelijke leemstreek", 
                                                       "Zandleemstreek")), 
                                 punten_totaal %>% 
                                   filter(regio %in% c("Westelijke leemstreek", 
                                                       "Zandleemstreek")))

# Cluster
clustering_2023 <- hclust(dist(mtx_distance_2023), method = "mcquitty")

clusters_20231 <- punten_totaal %>% 
  filter(regio %in% c("Westelijke leemstreek", "Zandleemstreek")) %>%
  mutate(groep = cutree(clustering_2023, k = nrow(mtx_distance_2023) %/% 8)) %>%
  group_by(groep) %>%
  mutate(n = n()) %>%
  ungroup() %>%
  mutate(groep = paste("westleem_zandleem", groep))
clusters_20231 <- clusters_20231 %>%
  mutate(dist = st_distance(geometry, clusters_20231 %>% filter(n == 1)))

# Herbereken solo punt
min_dist <- clusters_20231 %>% 
  filter(n != 1) %>% 
  arrange(dist) %>%
  head(1) %>%
  pull(groep)

group_n <- clusters_20231 %>% 
  filter(groep == min_dist) %>% 
  pull(n) %>% 
  unique()

clusters_2023 <- clusters_20231 %>%
  mutate(groep = ifelse(n == 1, min_dist, groep),
         n = ifelse(groep == min_dist, group_n + 1, n))

# Visualiseer
mapview(clusters_2023, zcol = "groep")
```

De gemiddelde groepgrootte in de Westelijke leemstreek en Zandleemstreek is `r clusters_2023$groep %>% table() %>% mean()`.  
  
De verdeling van alle clustergroottes ziet er als volgt uit:

```{r}
clustered_points <-
  bind_rows(
    clusters_dm,
    clusters_ol,
    clusters_2023
  ) %>%
  mutate(regio = ifelse(regio %in% c("Westelijke leemstreek", "Zandleemstreek"),
                        "Westelijke leemstreek/Zandleemstreek", regio))

clustered_points %>%
  distinct(groep, n) %>%
  ggplot() +
  geom_bar(aes(x = n)) +
  labs(x = "aantal telpunten per groep (cluster)",
       y = "aantal")
```


# Routeberekening

- centroïde van elke groep
- kortste afstand naar tellers
  - 2 tellers uit Roeselare
  - 2 tellers uit Gent
  - 1 teller uit Lier
  - 1 teller uit Leuven
  - 1 teller uit Nieuwerkerken (Limburg)

Voor elke groep telpunten berekenen we eerst het middelpunt (centroïde).

```{r}
centroids <- clustered_points %>%
  group_by(groep) %>%
  summarise(geometry = st_union(geometry)) %>%
  st_centroid() %>%
  left_join(clustered_points %>% st_drop_geometry(), by = "groep") %>%
  distinct(groep, regio, n, geometry)
```

We nemen voor elke stad de coördinaten van het stadscentrum.

```{r}
roeselare <- c(50.945005, 3.126043)
gent <- c(51.054445, 3.721669)
lier <- c(51.132355, 4.568008)
leuven <- c(50.878708, 4.700800)
nieuwekerken <- c(50.866632, 5.193651)
stad_matrix <- rbind(roeselare, gent, lier, leuven, nieuwekerken)

teller_adressen <- tibble(groep = rownames(stad_matrix), lat = stad_matrix[, 1], 
                          long = stad_matrix[, 2]) %>%
  st_as_sf(coords = c("long", "lat"), crs = st_crs(4326)) %>%
  st_transform(31370)

mapview(teller_adressen, zcol = "groep", layer = "groep")
```

We berekenen voor elke stad de korste afstand naar de centroïde van elke groep telpunten. Daarna selecteren we per groep de stad die het dichtstbij ligt.

```{r}
datalist <- vector("list", length = nrow(centroids) * nrow(teller_adressen))
i <- 1

for (cluster in 1:nrow(centroids)) {
  for (teller in 1:nrow(teller_adressen)) {
    dist <- osrmTrip(loc = rbind(centroids[cluster, c(1, 2)], 
                       teller_adressen[teller, c(1, 2)]))[[1]]$summary$distance
    
    test <- centroids[cluster, 1] %>% 
      st_drop_geometry() %>% 
      pull(groep)
    
    stad <- teller_adressen[teller, 1] %>% 
      st_drop_geometry() %>% 
      pull(groep)
    
    df <- data.frame(groep = test, 
                     stad,
                     dist)
    
   datalist[[i]] <- df
   i <- i + 1
  }
}

afstanden_centroid <- do.call(rbind, datalist) %>%
  group_by(groep) %>%
  filter(dist == min(dist)) %>%
  left_join(clustered_points %>% st_drop_geometry(), by = "groep") %>%
  distinct(groep, stad, dist = dist.x, regio, n) %>%
  ungroup()
```

Nu kunnen we de kortste routes berekenen tussen de tellers (stad) en de punten per cluster. We moeten de functie `osmrTrip()` lichtjes aanpassen omdat de punten vaak niet op harde wegen liggen en dichtbij elkaar waardoor er een probleem is bij de output van de functie. Daarom outputten we geen info over de individuele lijnsegmenten, maar enkel de afstand van het kortste traject (zie: <https://github.com/riatelab/osrm/issues/120>)

```{r}
osrmTrip_nogeom <- function(loc, exclude = NULL, overview = "simplified", 
  returnclass, osrm.server = getOption("osrm.server"), 
  osrm.profile = getOption("osrm.profile")) {
  
  opt <- options(error = NULL)
  on.exit(options(opt), add = TRUE)
  if (!missing(returnclass)) {
    warning("\"returnclass\" is deprecated.", call. = FALSE)
  }
  url <- osrm:::base_url(osrm.server, osrm.profile, "trip")
  loc <- osrm:::input_route(x = loc, id = "loc", single = FALSE, 
    all.ids = TRUE)
  oprj <- loc$oprj
  url <- paste0(url, paste(osrm:::clean_coord(loc$lon), osrm:::clean_coord(loc$lat), 
    sep = ",", collapse = ";"), "?steps=false&geometries=geojson&overview=", 
    tolower(overview), "&generate_hints=false")
  if (!missing(exclude)) {
    url <- paste0(url, "&exclude=", exclude)
  }
  e <- try({
    req_handle <- curl::new_handle(verbose = FALSE)
    curl::handle_setopt(req_handle, useragent = "osrm_R_package")
    r <- curl::curl_fetch_memory(utils::URLencode(url), 
      handle = req_handle)
  }, silent = TRUE)
  if (inherits(e, "try-error")) {
    stop(e, call. = FALSE)
  }
  osrm:::test_http_error(r)
  res <- RcppSimdJson::fparse(rawToChar(r$content))
  waypointsg <- data.frame(res$waypoints[, c(1, 2, 5)], matrix(unlist(res$waypoints$location), 
    byrow = T, ncol = 2), id = loc$id)
  ntour <- dim(res$trips)[1]
  trips <- vector("list", ntour)
  for (nt in 1:ntour) {
    geodf <- data.frame(res$trips[nt, ]$geometry[[1]]$coordinates)
    if (geodf[nrow(geodf), 1] != geodf[1, 1]) {
      geodf <- rbind(geodf, geodf[1, ])
    }
    geodf$ind <- 1:nrow(geodf)
    waypoints <- waypointsg[waypointsg$trips_index == (nt - 
      1), ]
    geodf <- merge(geodf, waypoints, by.x = c("X1", "X2"), 
      by.y = c("X1", "X2"), all.x = T)
    geodf <- geodf[order(geodf$ind, decreasing = F), ]
    indexes <- geodf[!is.na(geodf$waypoint_index), "ind"]
    wktl <- rep(NA, nrow(waypoints))
    for (i in 1:(length(indexes) - 1)) {
      ind0 <- indexes[i]
      ind1 <- indexes[i + 1]
      if (ind1 == ind0) {
        aind <- rep(ind0, 2)
      }
      else {
        aind <- ind0:ind1
      }
      wktl[i] <- paste("LINESTRING(", paste(geodf[aind, 
        1], " ", geodf[aind, 2], sep = "", collapse = ","), 
        ")", sep = "")
    }
    start <- (waypoints[order(waypoints$waypoint_index, 
      decreasing = F), "id"])
    end <- start[c(2:length(start), 1)]
    
    # https://github.com/riatelab/osrm/issues/120
    sldf <- tryCatch(
          expr  = st_sf(start = start, end = end, 
                  duration = res$trips[nt, ]$legs[[1]][, "duration"]/60, 
                  distance = res$trips[nt, ]$legs[[1]][, "distance"]/1000, 
                  geometry = st_as_sfc(wktl, crs = 4326)),
          error = function(call) {
            message("An error occurred, only returning geometry of trip.")
            message("Here's the original error message:")
            message(paste(call))
            
            return(st_sf(geometry = st_as_sfc(wktl, crs = 4326)))
            }
          )
    
    tripSummary <- list(duration = res$trips[nt, ]$duration/60, 
      distance = res$trips[nt, ]$distance/1000)
    trips[[nt]] <- list(trip = sldf, summary = tripSummary)
  }
  return(trips)
}
```

```{r}
afstanden_new <- afstanden_centroid %>%
  left_join(teller_adressen, by = c("stad" = "groep")) %>%
  st_as_sf() %>%
  select(groep, stad, regio, n)

clusterd_new <- clustered_points %>%
  mutate(stad = NA) %>%
  select(groep, stad, regio, n)

afstanden_df <- bind_rows(afstanden_new, clusterd_new) %>% 
  group_by(groep) %>%
  mutate(afstand = osrmTrip_nogeom(loc = geometry)[[1]]$summary$distance) %>%
  distinct(groep, stad, regio, n, afstand) %>%
  filter(!is.na(stad))
```

We visualiseren het resultaat voor clusters `"De Moeren 2"`, `"Oostelijke leemstreek 2"` en `"westleem_zandleem 9"`

```{r}
test1 <- osrmTrip(bind_rows(afstanden_new, clusterd_new) %>% 
                   filter(groep == "De Moeren 2"))
mapview(test1[[1]]$trip) + 
  mapview(bind_rows(afstanden_new, clusterd_new) %>% 
            filter(groep == "De Moeren 2"))

test2 <- osrmTrip(bind_rows(afstanden_new, clusterd_new) %>% 
                   filter(groep == "Oostelijke leemstreek 2"))
mapview(test2[[1]]$trip) + 
  mapview(bind_rows(afstanden_new, clusterd_new) %>% 
            filter(groep == "Oostelijke leemstreek 2"))

test2 <- osrmTrip(bind_rows(afstanden_new, clusterd_new) %>% 
                   filter(groep == "westleem_zandleem 9"))
mapview(test2[[1]]$trip) + 
  mapview(bind_rows(afstanden_new, clusterd_new) %>% 
            filter(groep == "westleem_zandleem 9"))
```

De kaarten tonen aan dat de berekeningen verlopen zijn zoals verwacht. De verdeling van de afstanden ziet er als volgt uit:

```{r}
afstanden_df %>%
  ggplot() +
    geom_histogram(aes(x = afstand)) +
    labs(x = "afstand", y = "aantal")
```

Nu zitten we nog met de uitdaging dat de groepen van punten sterk verschillen in grootte. We kunnen er wel van uitgaan dat een groep van punten 16 punten in 2 dagen kan bezocht worden (dus afstand vermenigvuldigen met 2) en dat twee groepen van 3 punten samen in 1 dag kunnen bezocht worden (afstand elke groep vermenigvuldigen met 0.5).

## Minimum scenario

- aantal keer op en neer naar groep punten
  - 0.5 voor clusters met 2-5 telpunten
  - 1 voor clusters met 6-10 telpunten
  - 1.5 voor clusters met 11-15 telpunten
  - 2 voor clusters met 16-20 telpunten

```{r}
afstanden_df_min <- afstanden_df %>%
  mutate(
    factor = case_when(
      n <= 5 ~ 0.5,
      n > 5 & n <= 10 ~ 1,
      n > 10 & n <= 15 ~ 1.5,
      n > 15 ~ 2
      ),
    tot_dist = afstand * factor)
```

```{r}
afstanden_df_min_sum <- afstanden_df_min %>%
  st_drop_geometry() %>%
  group_by(regio) %>%
  summarise(route_afstanden = sum(tot_dist)) %>%
  mutate(eenheid = "km")
afstanden_df_min_sum %>%
  kable()
```

De totale afstand die in dit scenario zal worden afgelegd is `r sum(afstanden_df_min_sum$route_afstanden)` km.  
  
We houden in dit minimum scenario echter geen rekening dat er ook een afstand is tussen twee clusters met factor 0.5. Daarom werken we in het volgende een scenario uit zonder halve clusters.

## Maximum scenario

- aantal keer op en neer naar groep punten
  - 1 voor clusters met 2-5 telpunten
  - 1 voor clusters met 6-10 telpunten
  - 2 voor clusters met 11-15 telpunten
  - 2 voor clusters met 16-20 telpunten

```{r}
afstanden_df_max <- afstanden_df_min %>%
  mutate(factor = ceiling(factor),
         tot_dist = afstand * factor)
```

```{r}
afstanden_df_max_sum <- afstanden_df_max %>%
  st_drop_geometry() %>%
  group_by(regio) %>%
  summarise(route_afstanden = sum(tot_dist)) %>%
  mutate(eenheid = "km")
afstanden_df_max_sum %>%
  kable()
```

De totale afstand die in dit scenario zal worden afgelegd is `r sum(afstanden_df_max_sum$route_afstanden)` km.


# Samenvatting

```{r}
bind_rows(afstanden_df_min_sum %>% mutate(scenario = "minimum"), 
          afstanden_df_max_sum %>% mutate(scenario = "maximum")) %>%
  select(scenario, everything()) %>%
  group_by(scenario) %>%
  mutate(totaal_per_scenario = sum(route_afstanden)) %>%
  select(scenario, regio, afstand_per_regio = route_afstanden, 
         totaal_per_scenario) %>%
  mutate(eenheid = "km") %>%
  kable(digits = 2)
```

In het minimumscenario wordt in totaal `r sum(afstanden_df_min_sum$route_afstanden)` km afgelegd. In het maximumscenario wordt in totaal `r sum(afstanden_df_max_sum$route_afstanden)` km afgelegd.  
  
We zijn er hierbij van uitgegaan dat:

- Tellers per teldag alle punten van 1 cluster bezoeken (in het minimum scenario ook alle punten van 2 clusters bij kleine clusters)
- Tellers telkens de meest korte route nemen naar telpunten en tussen punten van eenzelfde cluster
- Alle eerste 50 punten van de nieuwe steekproef van 2023 worden geteld (geen punten beschouwd uit de reserve batch)
- Een cluster punten wordt bezocht door de dichtsbijwonende teller
