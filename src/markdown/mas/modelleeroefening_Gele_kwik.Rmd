---
title: "Modelleren en distance sampling Gele kwikstaart"
author: "Ward Langeraert"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
renv::restore()
library(Distance)
library(territoria)
library(DBI)
library(Hmisc)
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE)
opts_knit$set(root.dir = here::here())
library(tidyverse)
library(gridExtra)
library(sf)
library(lubridate)
library(targets)
library(terra)
library(brms)
targets_store <- here("src", "targets", "mas_steekproef_pilootfase", "_targets")
source(here("src", "R", "berekening_hulpvariabelen.R"))
source(here("src", "R", "wfs_wcs.R"))
```


# Inlezen data

```{r ronde-intervallen}
r1_start <- "04-01"
r1_stop <- "04-20"
r2_start <- "04-21"
r2_stop <- "05-10"
r3_start <- "05-11"
r3_stop <- "06-10"
r4_start <- "06-21"
r4_stop <- "07-15"
```

```{r inlezen-mas-data}
mas <- read_sf(
  here("data/mas/20220906_qgis_export_sovon_wfs.gpkg")) %>%
  mutate(
    datum = ymd(paste(jaar, maand, dag, sep = "-")),
    periode_in_jaar = case_when(
      datum %within% interval(
        ymd(paste(jaar, r1_start, sep = "-")),
        ymd(paste(jaar, r1_stop, sep = "-"))) ~ "R1",
      datum %within% interval(
        ymd(paste(jaar, r2_start, sep = "-")),
        ymd(paste(jaar, r2_stop, sep = "-"))) ~ "R2",
      datum %within% interval(
        ymd(paste(jaar, r3_start, sep = "-")),
        ymd(paste(jaar, r3_stop, sep = "-"))) ~ "R3",
      datum %within% interval(
        ymd(paste(jaar, r4_start, sep = "-")),
        ymd(paste(jaar, r4_stop, sep = "-"))) ~ "R4"
    ))
```

```{r design2022}
design2022 <- read_csv(here(
    "data",
    "processed",
    "steekproef_piloot_avimap.csv")) %>%
  select(plotnaam = definitief_punt,
         regio,
         stratum) %>%
  mutate(openheid = ifelse(grepl("HOL", stratum), "HOL", "OL"),
         sbp = ifelse(grepl("binnen", stratum), "binnen", "buiten"),
         stratum = gsub("L\\s{1}", "L\\\n", stratum))
```

```{r design-2018-2022}
telpunten_avimap_2021 <- read_sf(
  here("data", "mas",
       "avimap_514_0_MAS_Werkgroep_Grauwe_Kiekendief_Belgi__telpunten_xy.shp")
) %>%
  rename(teller_2021 = teller) %>%
  mutate(
    regio = ifelse(is.na(regio), "Vlaanderen - Bilzen", regio),
    type_teller_2021 = case_when(
      teller_2021 %in% c("WVNT00", "JJNN16", "NOVN00") |
        regio == "Vlaanderen - Leefdaal" ~ "professioneel",
      is.na(teller_2021) &
        regio != "Vlaanderen - Leefdaal" ~ "niet geteld in 2021",
      TRUE ~ "vrijwilliger")) %>%
  select(-st_x, -st_y)

perimeters <- read_sf(
  here("data", "processed", "piloot_perimeters.gpkg"))

vlaanderen <- get_feature_wfs(
  wfs = "https://eservices.minfin.fgov.be/arcgis/services/R2C/Regions/MapServer/WFSServer",
  layername = "regions",
  crs = "EPSG:31370",
  filter = "<Filter><PropertyIsEqualTo><PropertyName>regions:NameDUT</PropertyName><Literal>'Vlaams Gewest'</Literal></PropertyIsEqualTo></Filter>") %>%
  select(NameDUT)


sbp_akkervogels <- tar_read(sbp_akkervogels,
                            store = targets_store)

design_2018_2021 <- add_openheid_landschap_to_frame(
  path = here("data", "dem",
    "openness300m_chm_res25_c300_mean_vlaanderen.tif"),
  punten_sf = telpunten_avimap_2021,
  gebied = vlaanderen,
  cutlevels = c(1.25, 1.35, 1.51),
  class_labels = c("GL", "HGL", "HOL", "OL")) %>%
  select(plotnaam = naam, regio, openheid = openheid_klasse) %>%
  mutate(sbp = st_intersects(.,
                             st_union(sbp_akkervogels),
                             sparse = FALSE) %>%
           as.logical(),
         sbp = ifelse(sbp, "binnen", "buiten")
  ) %>%
  st_drop_geometry() %>%
  mutate(stratum = paste0(openheid, "\n", sbp, " plan"),
         regio = gsub("Vlaanderen - ", "", regio),
         regio = ifelse(regio == "Leemstreek", "Oostelijke leemstreek", regio))
 
plotlijst_2018_2022 <- mas %>%
  st_drop_geometry() %>%
  distinct(plotnaam) %>%
  arrange(plotnaam)

design_2018_2022 <- bind_rows(
  design_2018_2021,
  design2022) %>%
  distinct() %>%
  arrange(plotnaam)
# er zitten duplos in (zie volgende chunk)
```

```{r probleemgevallen, eval=FALSE}
# probleemgevallen met verschillende classificatie
is_duplo <- duplicated(design_2018_2022$plotnaam)
duplo_plotnaam <- design_2018_2022 %>%
  select(plotnaam) %>%
  filter(is_duplo)
design_2018_2022 %>%
  inner_join(duplo_plotnaam) %>%
  View()

# volgens bestand buiten plan, maar lijkt niet te kloppen
# iets mis in targets analyse pipeline?
avimap <- telpunten_avimap_2021 %>%
  filter(naam == "VL0003")

read_csv(here(
    "data",
    "processed",
    "steekproef_piloot_avimap.csv")) %>%
  filter(definitief_punt == "VL0003") %>%
  st_as_sf(coords = c("X", "Y"), crs = 31370) %>%
  mapview::mapview()  +
  mapview::mapview(sbp_akkervogels, col.regions = "yellow") +
  mapview::mapview(avimap)

read_csv(here(
    "data",
    "processed",
    "steekproef_piloot_avimap.csv")) %>%
  inner_join(duplo_plotnaam, by = c("definitief_punt" = "plotnaam")) %>%
  st_as_sf(coords = c("X", "Y"), crs = 31370) %>%
  mapview::mapview()  +
  mapview::mapview(sbp_akkervogels, col.regions = "yellow")
```

```{r omzeilen-probleemgevallen}
# probleemgevallen voorlopig omzeilen
design_2018_2022 <- bind_rows(
  design_2018_2021,
  design2022 %>%
    filter(!grepl("^VL", plotnaam))) %>%
  distinct() %>%
  arrange(plotnaam)
```

```{r overzicht-data, eval=FALSE}
head(mas)
summary(mas)
glimpse(mas)
```

Dubbeltellingen zijn eruit (soort gezien op meerdere teldagen binnen eenzelfde telperiode): in dat geval de laatste teldag genomen.

```{r check-dubbeltelling}
dubbels <- mas %>%
  st_drop_geometry() %>%
  group_by(plotid, jaar, periode_in_jaar, soortnr) %>%
  summarize(aantal_teldagen = n_distinct(doy),
            .groups = "drop") %>%
  filter(aantal_teldagen > 1)
# kan zowel zelfde waarnemer als andere waarnemer zijn

mas_clean <- mas %>%
  semi_join(dubbels, by = c("plotid", "jaar", "periode_in_jaar")) %>%
  group_by(plotid, jaar, periode_in_jaar) %>%
  filter(doy == max(doy)) %>%
  ungroup() %>%
  bind_rows(mas %>%
              anti_join(dubbels, by = c("plotid", "jaar", "periode_in_jaar")))
```


# Gele kwikstaart 2022

We starten met een beperkte dataset om het aantal broedparen van de Gele kwikstaart te modelleren. We beginnen met data exploratie en bouwen dan verschillende modellen op van simpel naar meer complexe modellen. 

We selecteren de data voor Gele kwikstaart van 2022 met broedcode > 0. Opmerking: wat met *Gele kwikstaart (spec)*?

```{r selectie-gelekwik-2022}
# Selecteer tellingen van Gele kwikstaart in 2022 in de twee regios
# met broedcode > 0 en binnen telrondes
gele_kwik_2022_presences <- mas_clean %>% 
  st_drop_geometry() %>%
  filter(naam == "Gele Kwikstaart", jaar == 2022, 
         !is.na(periode_in_jaar), wrntype > 0L) %>%  
  inner_join(design2022, by = "plotnaam") # Moeren en Leemstreek

# Totale lijst van bezochte plots in 2022
bezoekenlijst_2022 <- design2022 %>% 
  expand_grid(distinct(mas_clean, periode_in_jaar)) %>% # voeg telperiodes toe
  filter(!is.na(periode_in_jaar))

# Voeg afwezigheden toe door te mergen met alle bezoeken
gele_kwik_2022 <- gele_kwik_2022_presences %>%
  group_by(plotnaam, periode_in_jaar) %>%
  summarise(aantal = sum(aantal)) %>% # som aantallen gespot per dag 
  full_join(bezoekenlijst_2022, by = c("plotnaam", "periode_in_jaar")) %>%
  replace(is.na(.), 0) %>%
  arrange(plotnaam, periode_in_jaar)
```


## Data exploratie

Enkele samenvattende statistieken:

```{r stats-aantallen-nodist}
gele_kwik_2022 %>%
  group_by(regio, periode_in_jaar) %>%
  summarise(min = min(aantal), 
            mediaan = median(aantal),
            gemiddelde = mean(aantal),
            max = max(aantal),
            varantie = var(aantal)) %>%
  kable()
```

Aantal tellingen per categorie:

```{r tellingen-aantallen-nodist}
gele_kwik_2022 %>%
  group_by(regio, periode_in_jaar, aantal) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(aantal) %>%
  pivot_wider(names_from = aantal, values_from = n) %>%
  replace(is.na(.), 0) %>%
  kable()
```

Verdeling van de tellingen:

```{r histogram-aantallen-nodist}
gele_kwik_2022 %>%
  group_by(regio, periode_in_jaar, aantal) %>%
  summarise(n = n(), .groups = "drop_last") %>%
  ggplot(aes(x = aantal, y = n, fill = regio)) +
    geom_bar(stat = "identity", col = "black") +
    theme(panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank()) + 
    facet_wrap(~periode_in_jaar, scales = "free") +
    labs(y = "", x = "Aantal broedparen Gele kwikstaart per plot")
```

Totaal aantal getelde broedparen Gele kwikstaart per telcirkel met aanduiding van gemiddelde en 95% bootstrap betrouwbaarheidsinterval.

```{r boxplots-aantallen-nodist}
gele_kwik_2022 %>%
  ggplot(aes(x = periode_in_jaar, y = aantal, colour = periode_in_jaar)) +
  stat_sum(position = position_dodge(width = 0.5), alpha = 0.5) +
  stat_summary(fun.data = mean_cl_boot,
               position = position_dodge(width = 0.5),
               fatten = 4, shape = "square") +
  facet_wrap(~regio) +
  labs(y = "Aantal broedparen Gele kwikstaart per plot", x = "Telperiode")
```


## Generalized linear mixed models

**Op verkenning**

Voorlopig houden we geen rekening met detectiekans. We sommen de aantallen op per plot per telperiode (elke plot is 1x per telperiode bezocht). Met deze data fitten we een model waarbij de aantallen broedparen Gele kwikstaart per telcirkel afhangen van regio en een effect van tijdstip van de telling in 2022. Als random effect wordt de plot in het model gestoken om rekening te houden met gepaardheid van de waarnemingen doorheen het jaar. 

We fitten vier modellen met verschillende verdelingsassumpties:

1. Poisson
2. Negative binomial
3. Zero-inflated Poisson
4. Zero-inflated Negative binomial

\textcolor{red}{opmerking:} Met de optie `sample_prior = "only"` kunnen bijkomend trekkingen worden getrokken van de priors, waarbij de likelihood wordt genegeerd. Daarmee kan er gesampled worden van de prior predictive distribution. Hiermee kunnen de gebruikte priors gecontroleerd worden. Echter deze optie is nu niet mogelijk aangezien sommige parameters improper priors hebben: `Error occurred for parameter 'b'.`.

```{r fit-GLMMs, results=FALSE, fig.show='hide'}
# Save brms models to this path
model_path <- "./src/markdown/mas/brms_models/"
models <- c("Poisson", "Negative binomial", "Zero-inflated Poisson", 
            "Zero-inflated Negative binomial")

# MCMC parameters
nchains <- 3           # number of chains
niter <- 4000          # number of iterations (incl. burn-in)
burnin <- niter / 2    # number of initial samples to discard (burn-in)
nparallel <- nchains   # number of cores used for parallel computing

# 1. Poisson
brmpois1 <- brm(bf(aantal ~ regio + periode_in_jaar + (1 | plotnaam)), 
                data = gele_kwik_2022, family = poisson(), 
                chains = nchains, warmup = burnin, iter = niter, 
                cores = nparallel,
                file = paste0(model_path, "brmpois1"),
                file_refit = "on_change")
summary(brmpois1)
plot(brmpois1)

# 2. Negative binomial
brmnegbin1 <- brm(bf(aantal ~ regio + periode_in_jaar + (1 | plotnaam)), 
                  data = gele_kwik_2022, family = negbinomial(), 
                  chains = nchains, warmup = burnin, iter = niter, 
                  cores = nparallel,
                  file = paste0(model_path, "brmnegbin1"),
                  file_refit = "on_change")
summary(brmnegbin1)
plot(brmnegbin1)

# 3. Zero-inflated Poisson
brmZIP1 <- brm(bf(aantal ~ regio + periode_in_jaar + (1 | plotnaam)), 
               data = gele_kwik_2022, family = zero_inflated_poisson(), 
               chains = nchains, warmup = burnin, iter = niter, 
               cores = nparallel,
               file = paste0(model_path, "brmZIP1"),
               file_refit = "on_change")
summary(brmZIP1)
plot(brmZIP1)

# 4. Zero-inflated Negative binomial
brmZINB1 <- brm(bf(aantal ~ regio + periode_in_jaar + (1 | plotnaam)), 
                data = gele_kwik_2022, family = zero_inflated_negbinomial(), 
                chains = nchains, warmup = burnin, iter = niter, 
                cores = nparallel,
                file = paste0(model_path, "brmZINB1"),
                file_refit = "on_change")
summary(brmZINB1)
plot(brmZINB1)
```

Convergentie voor alle modellen ok (scale reduction factors, trace plots, posterior density).

**Model selectie en fit**

We vergelijken de modellen gebruikmakend van 5-fold cross-validation (CV) (leave one out CV en WAIC berekenen niet mogelijk, \textcolor{red}{waarom?}). Eerst worden de gegevens opgedeeld in $K$ delen (subsets) van gelijke (of zo goed mogelijk gelijke) grootte. Vervolgens wordt het model $K$ keer gefit, waarbij telkens een van de $K$ subsets wordt weggelaten. We stratificeren volgens regio. Hierbij wordt er voor gezorgt dat relatieve frequenties per regio bij benadering behouden blijven.

```{r k-foldCV-GLMMs}
# Perform K-fold cross-validation
if (!file.exists(paste0(model_path, "fit_brmpois1.rds"))) {
  fit_brmpois1 <- add_criterion(brmpois1, c("kfold"), K = 5, cores = 5,
                                folds = "stratified", group = "regio", 
                                file = paste0(model_path, "fit_brmpois1"))
  fit_brmnegbin1 <- add_criterion(brmnegbin1, c("kfold"), K = 5, cores = 5, 
                                folds = "stratified", group = "regio", 
                                file = paste0(model_path, "fit_brmnegbin1"))
  fit_brmZIP1 <- add_criterion(brmZIP1, c("kfold"), K = 5, cores = 5,
                                folds = "stratified", group = "regio", 
                                file = paste0(model_path, "fit_brmZIP1"))
  fit_brmZINB1 <- add_criterion(brmZINB1, c("kfold"), K = 5, cores = 5,
                                folds = "stratified", group = "regio",
                                file = paste0(model_path, "fit_brmZINB1"))
} else {
  fit_brmpois1 <- readRDS(paste0(model_path, "fit_brmpois1.rds"))
  fit_brmnegbin1 <- readRDS(paste0(model_path, "fit_brmnegbin1.rds"))
  fit_brmZIP1 <- readRDS(paste0(model_path, "fit_brmZIP1.rds"))
  fit_brmZINB1 <- readRDS(paste0(model_path, "fit_brmZINB1.rds"))
}

# Comparison among models
comparisons <- loo_compare(fit_brmpois1, fit_brmnegbin1, fit_brmZIP1, 
                           fit_brmZINB1, criterion = "kfold")[, c(1, 2)] %>%
                as.data.frame() %>%
                mutate(model = c("Poisson", "Zero-inflated Negative binomial",
                                 "Zero-inflated Poisson", "Negative binomial"))
```

```{r table-CV-GLMMs}
rbind(fit_brmpois1$criteria$kfold$estimates[, "Estimate"],
  fit_brmnegbin1$criteria$kfold$estimates[, "Estimate"],
  fit_brmZIP1$criteria$kfold$estimates[, "Estimate"], 
  fit_brmZINB1$criteria$kfold$estimates[, "Estimate"]
  ) %>%
  as.data.frame() %>%
  mutate(model = models) %>%
  full_join(comparisons, by = "model") %>%
  mutate(CI_ll = elpd_diff  + qnorm(0.025) * se_diff,
         CI_ul = elpd_diff  + qnorm(0.975) * se_diff) %>%
  select(model, everything()) %>%
  arrange(desc(elpd_diff)) %>%
  kable(digits = 3)
```

Het Poisson model toont het beste evenwicht tussen model parsimonie en model fit. Dat zien we ook bij de posterior predictive check. We vergelijken de waargenomen tellingen met gesimuleerde tellingen van de posterior predictive distribution. Bovendien voorspelt dit model geen onmogelijk grote waarden (ZINB voorspelt bijvoorbeeld grotere maxima terwijl we in de data slechts maximaal 6 individuen hadden).

```{r ppcheck-final-GLMM}
pp_check(fit_brmpois1, type = "bars_grouped", ndraws = 100, group = "regio",
         facet_args = list(ncol = 1, scales = "free_y"))

pp_check(fit_brmpois1, type = "bars_grouped", ndraws = 100, 
         group = "periode_in_jaar",
         facet_args = list(ncol = 1, scales = "free_y"))
```

**Resultaten en visualisatie**

Overzicht van de gefitte modelparameters, hun onzekerheid en enkele maten die aangeven of het model geconvergeerd is.

```{r parameters-final-GLMM}
summary(fit_brmpois1)
```

Visualisatie van de modelpredicties voor de verschillende regios en telperiodes.

```{r prediction-plots-final-GLMM}
pred <- conditional_effects(fit_brmpois1, effects = c("regio:periode_in_jaar"))

cirkelopp <- pi * 300^2
plot(pred, plot = FALSE)[[1]] + 
     scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
       name = "Aantal broedparen Gele kwikstaart per 100 ha")) +
     labs(y = "Aantal broedparen Gele kwikstaart per plot", x = "")
```

Testen van een hypothese. Voorbeeld: Is het gemiddeld aantal broedparen Gele kwikstaart significant lager in de Oostelijke leemstreek dan in De Moeren?

Hypothese:

\begin{aligned}
  &\frac{\exp(\beta_0) + \exp(\beta_0 + \beta_2) + \exp(\beta_0 + \beta_3) + \exp(\beta_0 + \beta_4)}{4} > \frac{\exp(\beta_0 + \beta_1) + \exp(\beta_0 + \beta_1 + \beta_2) + \exp(\beta_0 + \beta_1 + \beta_3) + \exp(\beta_0 + \beta_1 + \beta_4)}{4}\\
  &\Rightarrow \exp(\beta_0)(\exp(\beta_2) + \exp(\beta_3) + \exp(\beta_4)) > \exp(\beta_0)\exp(\beta_1)(\exp(\beta_2) + \exp(\beta_3) + \exp(\beta_4))\\
  &\Rightarrow \exp(\beta_1) < 1\\
  &\Rightarrow \beta_1 < 0
\end{aligned}

```{r hypothesis-regio}
hyp1 <- hypothesis(
  x = fit_brmpois1,
  "regioOostelijkeleemstreek < 0",
  class = "b", alpha = 0.05)
hyp1
plot(hyp1)
```

De evidence ratio is groot wat er op duidt dat er gemiddeld gezien een significant hoger aantal broedparen Gele kwikstaart in De Moeren aanwezig zijn. De evidence ratio is de verhouding tussen posterior probability a < b t.o.v. posterior probability a > b. De schatting is -0.47. Dit is een verschil in de log-schaal, dus als we dit exponentiëren bekomen we 0.63 keer minder broedparen Gele kwikstaart in de Oostelijke leemstreek dan in De Moeren.

Het toevoegen van een interactie `regio:periode_in_jaar` blijkt geen meerwaarde voor het model:

```{r GLMM-interaction, results=FALSE, fig.show='hide'}
brmpois2 <- brm(bf(aantal ~ regio + periode_in_jaar + regio:periode_in_jaar +
                     (1 | plotnaam)), 
                  data = gele_kwik_2022, family = poisson(), 
                  chains = nchains, warmup = burnin, iter = niter, 
                  cores = nparallel,
                  file = paste0(model_path, "brmpois2"),
                  file_refit = "on_change")

# Convergence ok
summary(brmpois2)
plot(brmpois2)
```

- Interactieparameters niet significant verschillend van nul.

```{r GLMM-interaction-hypotheses}
# Hypotheses
q1 <- "regioOostelijkeleemstreek:periode_in_jaarR2 = 0"
q2 <- "regioOostelijkeleemstreek:periode_in_jaarR3 = 0"
q3 <- "regioOostelijkeleemstreek:periode_in_jaarR4 = 0"

hypothesis(x = brmpois2, c(q1, q2, q3), class = "b", alpha = 0.05)
```

- K-fold cross-validation beter zonder interactie (toch grote standard error, maar dan opteren we voor het eenvoudigere model, i.e. zonder interactie)

```{r GLMM-interaction-CV}
# Perform K-fold cross-validation
if (!file.exists(paste0(model_path, "fit_brmpois2.rds"))) {
  fit_brmpois2 <- add_criterion(brmnegbin1, c("kfold"), K = 5, cores = 5,
                        folds = "stratified", group = "regio", 
                        file = paste0(model_path, "fit_brmpois2"))
} else {
  fit_brmpois2 <- readRDS(paste0(model_path, "fit_brmpois2.rds"))
}

# Comparison among models
comparisons <- loo_compare(fit_brmpois1, fit_brmpois2, 
                           criterion = "kfold")[, c(1, 2)] %>%
                as.data.frame() %>%
                mutate(model = c("Poisson: no interaction", 
                                 "Poisson: interaction"))

# Make nice table
rbind(fit_brmpois1$criteria$kfold$estimates[, "Estimate"],
  fit_brmpois2$criteria$kfold$estimates[, "Estimate"]
  ) %>%
  as.data.frame() %>%
  mutate(model = c("Poisson: no interaction", "Poisson: interaction")) %>%
  full_join(comparisons, by = "model") %>%
  mutate(CI_ll = elpd_diff  + qnorm(0.025) * se_diff,
         CI_ul = elpd_diff  + qnorm(0.975) * se_diff) %>%
  select(model, everything()) %>%
  kable(digits = 3)
```

- Visueel slechts klein verschil in predicties (R2 vs R3 De Moeren)

```{r GLMM-visual-comparison-interaction}
pred_interaction <- conditional_effects(brmpois2, 
                                        effects = c("regio:periode_in_jaar"))

p_pois1 <- plot(pred, plot = FALSE)[[1]] + 
                scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
                  name = ""), limits = c(0, 0.4)) +
                labs(y = "Aantal broedparen Gele kwikstaart per plot", x = "", 
                     title = "Poisson: no interaction") +
                theme(legend.position = "bottom")

p_pois2 <- plot(pred_interaction, plot = FALSE)[[1]] + 
                scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
                  name = "Aantal broedparen Gele kwikstaart per 100 ha"), 
                  limits = c(0, 0.4)) +
                labs(y = "", x = "", title = "Poisson: interaction") +
                theme(legend.position = "bottom")

grid.arrange(p_pois1, p_pois2, ncol = 2)
```

## Distance samling
### Distance package

**Op verkenning**

In de GLMM's houden we echter geen rekening met een afnemende detectiekans naarmate de dieren zich verder bevinden. In voorgaande sectie hadden we de data geaggregeerd per telcirkel per telperiode, in deze sectie werken we met de directe observaties: waarnemingen van $n$ aantal broedparen Gele kwikstaart op een afstand van $x$ meter van het telpunt per telperiode in 2022.

```{r data-dist}
gele_kwik_2022_distance <- gele_kwik_2022_presences %>%
  # Add absences
  full_join(bezoekenlijst_2022, by = c("plotnaam", "periode_in_jaar", "regio", 
                                       "stratum", "openheid", "sbp")) %>%
  # Replace NA's by 0's
  mutate(aantal = ifelse(is.na(aantal), 0, aantal)) %>%
  arrange(plotnaam, periode_in_jaar)

reg_tab <- perimeters %>% mutate(Area = as.numeric(st_area(geom)) / 1e6) %>%
            select(Naam, Area) %>%
            rename(regio = Naam) %>%
            st_drop_geometry()

conversion_factor <- convert_units("meter", NULL, "Square kilometer")
```

Wat is de verdeling van de geregistreerde afstanden? Afstanden van absences zijn `NA`.

```{r tabel-dist}
gele_kwik_2022_distance %>%
  group_by(regio, periode_in_jaar) %>%
  summarise(min = min(distance2plot, na.rm = TRUE), 
            mediaan = median(distance2plot, na.rm = TRUE),
            gemiddelde = mean(distance2plot, na.rm = TRUE),
            max = max(distance2plot, na.rm = TRUE),
            varantie = var(distance2plot, na.rm = TRUE)) %>%
  kable(digits = 1)
```

```{r histogram-dist}
gele_kwik_2022_distance %>%
  filter(!is.na(distance2plot)) %>%
  ggplot() +
    geom_histogram(aes(x = distance2plot, fill = periode_in_jaar),
                   bins = 30) +
    facet_wrap(~regio) +
    labs(y = "Aantal tellingen van Gele kwikstaart", x = "Afstand (m)",
         title = "2022")
```

**Data voorbereiden**

De dataframe moet een kolom met de naam `distance` bevatten (met de waargenomen afstanden) en extra benoemde kolommen voor eventuele covariaten die de detecteerbaarheid kunnen beïnvloeden (bijvoorbeeld waarnemer effect of visibiliteit). Om de densiteit te schatten of de abundatntie, is aanvullende informatie vereist. Extra kolommen moeten worden opgenomen de dataframe met vermelding van: `Sample.Label` (ID van het transect/plot), `Effort` (het aantal keren dat dat punt is bezocht); `Region.Label` (het stratum dat het transect bevat); `Area`, de oppervlakte van de strata. Transecten/plots die zijn onderzocht maar geen waarnemingen hebben, moeten worden opgenomen in de dataset met `NA` voor afstand en eventuele andere covariaten. De kolom `size`geeft de cluster groottes aan zodat elke rij een observatie van een cluster/groep is inplaats van een individu.

```{r dist-dataframe}
gele_kwik_2022_ds <- gele_kwik_2022_distance %>%
  select(plotnaam, regio, periode_in_jaar, aantal, distance2plot) %>%
  full_join(reg_tab, by = "regio") %>% 
  rename(Sample.Label = plotnaam, size = aantal, distance = distance2plot) %>%
  mutate(Region.Label = paste(regio, periode_in_jaar, sep = " - ")) %>%
  group_by(Sample.Label) %>%
  mutate(Effort = n_distinct(periode_in_jaar))
```

**Model selectie en fit**

We fitten 3 verschillende detectiefuncties die we laten afhangen van covariaten regio en telperiode. Voor de uniforme verdeling kunnen geen covariaten worden toegevoegd.

- Fitting uniform key function

```{r uniform-ds}
dsmodelunif1 <- ds(data = gele_kwik_2022_ds, key = "unif", truncation = 300, 
                 transect = "point", dht_group = FALSE,
                 convert_units = conversion_factor)
```

- Fitting half-normal key function

```{r halfnormal-ds}
dsmodelhn1 <- ds(data = gele_kwik_2022_ds, key = "hn", truncation = 300, 
                 transect = "point", dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhn2 <- ds(data = gele_kwik_2022_ds, key = "hn", formula = ~ regio,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhn3 <- ds(data = gele_kwik_2022_ds, key = "hn", 
                 formula = ~ periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhn4 <- ds(data = gele_kwik_2022_ds, key = "hn", 
                 formula = ~ regio + periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhn5 <- ds(data = gele_kwik_2022_ds, key = "hn", 
                 formula = ~ regio + periode_in_jaar + 
                   regio:periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)
```

- Fitting hazard-rate key function

```{r hazard-rate-ds}
dsmodelhr1 <- ds(data = gele_kwik_2022_ds, key = "hr", truncation = 300, 
                 transect = "point", dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhr2 <- ds(data = gele_kwik_2022_ds, key = "hr", formula = ~ regio,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhr3 <- ds(data = gele_kwik_2022_ds, key = "hr", 
                 formula = ~ periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhr4 <- ds(data = gele_kwik_2022_ds, key = "hr", 
                 formula = ~ regio + periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)

dsmodelhr5 <- ds(data = gele_kwik_2022_ds, key = "hr", 
                 formula = ~ regio + periode_in_jaar + 
                   regio:periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor)
```

We bekijken model fit m.b.v. QQ-plots en probability density function plots. Voor punttransectstudies geven probability density function plots een beter idee van modelfit dan de detectiefunctieplots. Dit komt omdat bij het plotten van de detectiefunctie voor punttransectgegevens, de histogram opnieuw moet worden geschaald om rekening te houden met de geometrie van de punt. Punten op de plot geven de kans op detectie voor elke waarneming aan.

```{r model-fit-ds}
par(mfrow = c(1, 2))

# Uniform model
gof_ds(dsmodelunif1, main = "dsmodelunif1")
plot(dsmodelunif1, pdf = TRUE, 
     main = paste0("dsmodelunif1 - ", "AIC: ", 
                   as.character(round(summary(dsmodelunif1)$ds$aic, digits = 2))
                   )
     )

# Half-normal models
for (i in 1:5) {
  mod <- get(paste0("dsmodelhn", i))
  name <- paste0("dsmodelhn", i)
  
  gof_ds(mod, main = name)
  
  plot(mod, pdf = TRUE, 
       main = paste0(name, " - ", "AIC: ",
                     as.character(round(summary(mod)$ds$aic, digits = 2))
                     )
       )
}

# Hazard-rate models
for (i in 1:5) {
  mod <- get(paste0("dsmodelhr", i))
  name <- paste0("dsmodelhr", i)
  
  gof_ds(mod, main = name)
  
  plot(mod, pdf = TRUE, 
       main = paste0(name, " - ", "AIC: ",
                     as.character(round(summary(mod)$ds$aic, digits = 2))
                     )
       )
}

par(mfrow = c(1, 1))
```

We vergelijken de AIC van de verschillende modellen. Als het verschil tussen AIC's kleiner is dan 2, kiezen we het eenvoudigste van deze modellen. Modellen met vergelijkbare AIC's hebben vergelijkbare geschatte detectiekansen,
dus in de praktijk is er weinig verschil in de keuze tussen deze modellen.

```{r model-comparisons-ds}
summarize_ds_models(dsmodelunif1, 
                    dsmodelhn1, dsmodelhn2, dsmodelhn3, 
                    dsmodelhn4, dsmodelhn5, 
                    dsmodelhr1, dsmodelhr2, dsmodelhr3, 
                    dsmodelhr4, dsmodelhr5) %>%
  kable()
```

**Resultaten en visualisatie**

Op basis van deze redenering kiezen we voor model 7 met de Hazard-rate functie en zonder covariaten. Dit model geeft de volgende detectiekans:

```{r final-model-summary-ds}
summary_hr1 <- summary(dsmodelhr1)
summary_hr1$ds$coeff$key.scale %>%
  kable(digits = 2)

plot(dsmodelhr1)
```

De schattingen van abundantie (totaal aantal broedparen voor de volledige regio) en voor densiteit (aantal broedparen per 100 ha):

```{r visualise-final-model-ds}
summary_results <- bind_rows(
  summary_hr1$dht$clusters$D %>%
    mutate(variable = "density",
           type = "clusters"),
  summary_hr1$dht$clusters$N %>%
    mutate(variable = "abundance",
           type = "clusters"),
  summary_hr1$dht$individuals$D %>%
    mutate(variable = "density",
           type = "individuals"),
  summary_hr1$dht$individuals$N %>%
    mutate(variable = "abundance",
           type = "individuals")
  ) %>%
  as_tibble() %>%
  separate(Label, c("regio", "periode_in_jaar"), sep = " - ") %>%
  filter(!is.na(periode_in_jaar))

summary_results %>%
  filter(type == "individuals") %>%
  mutate(variable = recode_factor(variable, 
            abundance = "Totaal aantal broedparen Gele kwikstaart",
            density = "Aantal broedparen Gele kwikstaart per 100 ha")) %>%
  ggplot(aes(x = regio, y = Estimate)) + 
  geom_pointrange(aes(ymin = lcl, ymax = ucl, colour = periode_in_jaar),
                  position = position_dodge(width = 0.5)) + 
  facet_wrap(~variable, scales = "free_y") +
  labs(x = "", y = "")
```

Echter, voor de densiteit (aantal per 100 ha) worden het totaal aantal broedparen gedeeld door de oppervlakte van de volledige regio. Dit terwijl we enkel cirkels met radius 300 m hebben onderzocht waarbinnen we gecontroleerd hebben voor detectiekans (`truncation = 300`). Het lijkt dus logischer te kijken naar het geschatte aantal broedparen per plot en dan om te zetten naar densiteit per 100 ha m.b.v. de oppervlakte van de telcirkel. De densiteiten worden zo wel een stuk groter.

```{r visualise-final-model-ds-per-plot}
plots_per_regio <- gele_kwik_2022 %>% 
                     group_by(regio) %>% 
                     summarise(n_plots = n_distinct(plotnaam), .groups = "drop")

summary_results %>%
  filter(type == "individuals", variable == "abundance") %>%
  full_join(plots_per_regio, by = "regio") %>%
  mutate(Estimate = Estimate / n_plots,
         lcl = lcl / n_plots,
         ucl = ucl / n_plots) %>%
  ggplot(aes(x = regio, y = Estimate)) + 
  geom_point(aes(colour = periode_in_jaar), size = 4, 
             position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = lcl, ymax = ucl, colour = periode_in_jaar), 
                width = 0.25, position = position_dodge(width = 0.5)) + 
  scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
       name = "Aantal broedparen Gele kwikstaart per 100 ha")) +
  labs(x = "", y = "Aantal broedparen Gele kwikstaart per plot")
```

Zo kunnen we ook eenvoudiger vergelijken met de vorige resultaten waarbij we geen detectiekans in beschouwing namen.

```{r comparison-GLMM-ds}
GLMM_model <- plot(pred, plot = FALSE)[[1]] + 
                scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
                  name = ""), limits = c(0, 2.5)) +
                labs(y = "Aantal broedparen Gele kwikstaart per plot", x = "", 
                     title = "GLMM (brms)") +
                theme(legend.position = "bottom")

dist_model <- summary_results %>%
  filter(type == "individuals", variable == "abundance") %>%
  full_join(plots_per_regio, by = "regio") %>%
  mutate(Estimate = Estimate / n_plots,
         lcl = lcl / n_plots,
         ucl = ucl / n_plots) %>%
  ggplot(aes(x = regio, y = Estimate)) + 
  geom_point(aes(colour = periode_in_jaar), size = 4, 
             position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = lcl, ymax = ucl, colour = periode_in_jaar), 
                width = 0.25, position = position_dodge(width = 0.5)) + 
  scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
       name = "Aantal broedparen Gele kwikstaart per 100 ha"), limits = c(0, 2.5)) +
  labs(x = "", y = "", title = "Distance sampling (Distance)") +
  theme(legend.position = "bottom")

grid.arrange(GLMM_model, dist_model, ncol = 2)
```

De schattingen van densiteit liggen duidelijk hoger dan bij de analyse waarbij we geen rekening hielden met detectiekans. De relatieve verschillen tussen de jaren en regio’s blijven min of meer dezelfde. Bij distance sampling hebben we wel verschillende trends over telperiodes tussen regio's. Dit laatste hebben we niet opgenomen in het GLMM (geen interactieterm). Ook was de densiteit lager in de Oostelijke leemstreek dan De Moeren in het GLMM terwijl we dit in het distance model niet meer zien. 

**Discussie**

Andere covariaten die invloed zouden kunnen hebben op de detectiekans zijn voorlopig niet beschouwd (ervaring teller, visibiliteit, uur na zonsopkomst ...?).  

We zien een vrij stijle detectiefunctie wat er voor zorgt dat waarnemingen op grote afstanden een hoog gewicht krijgen wat mogelijks tot een overschatting leidt. We kunnen de afstanden ook in categorieën opsplitsen. bijvoorbeeld 0-100, 100-200 en 200-300. Dit is mogelijks een meer robuuste methode. Met de optie `cutpoints` in de `ds()` functie is dit eenvoudig toe te passen.

- Fitting uniform key function

```{r uniform-ds-binned}
# Set max adjustments to 2 otherwise not enough degrees of freedom
dsmodelunif1_binned <- ds(data = gele_kwik_2022_ds, key = "unif", 
                 truncation = 300, cutpoints = c(0, 100, 200, 300),
                 transect = "point", dht_group = FALSE,
                 convert_units = conversion_factor, max_adjustments = 2)
```

- Fitting half-normal key function

```{r halfnormal-ds-binned}
dsmodelhn1_binned <- ds(data = gele_kwik_2022_ds, key = "hn", truncation = 300, 
                 transect = "point", dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhn2_binned <- ds(data = gele_kwik_2022_ds, key = "hn", formula = ~ regio,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhn3_binned <- ds(data = gele_kwik_2022_ds, key = "hn", 
                 formula = ~ periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhn4_binned <- ds(data = gele_kwik_2022_ds, key = "hn", 
                 formula = ~ regio + periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhn5_binned <- ds(data = gele_kwik_2022_ds, key = "hn", 
                 formula = ~ regio + periode_in_jaar + 
                   regio:periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))
```

- Fitting hazard-rate key function

```{r hazard-rate-ds-binned}
dsmodelhr1_binned <- ds(data = gele_kwik_2022_ds, key = "hr", truncation = 300, 
                 transect = "point", dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhr2_binned <- ds(data = gele_kwik_2022_ds, key = "hr", formula = ~ regio,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhr3_binned <- ds(data = gele_kwik_2022_ds, key = "hr", 
                 formula = ~ periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhr4_binned <- ds(data = gele_kwik_2022_ds, key = "hr", 
                 formula = ~ regio + periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))

dsmodelhr5_binned <- ds(data = gele_kwik_2022_ds, key = "hr", 
                 formula = ~ regio + periode_in_jaar + 
                   regio:periode_in_jaar,
                 adjustment = NULL, truncation = 300, transect = "point", 
                 dht_group = FALSE,
                 convert_units = conversion_factor, 
                 cutpoints = c(0, 100, 200, 300))
```

We vergelijken de AIC van de verschillende modellen. Als het verschil tussen AIC’s kleiner is dan 2, kiezen we het eenvoudigste van deze modellen. Modellen met vergelijkbare AIC’s hebben vergelijkbare geschatte detectiekansen, dus in de praktijk is er weinig verschil in de keuze tussen deze modellen.

```{r model-comparisons-ds-binned}
summarize_ds_models(dsmodelunif1_binned, 
                    dsmodelhn1_binned, dsmodelhn2_binned, dsmodelhn3_binned, 
                    dsmodelhn4_binned, dsmodelhn5_binned, 
                    dsmodelhr1_binned, dsmodelhr2_binned, dsmodelhr3_binned, 
                    dsmodelhr4_binned, dsmodelhr5_binned) %>% 
  kable()
```

We zien dat de eenvoudigste modellen dicht bij elkaar liggen op vlak van AIC. We vergelijken model fit. Er zijn niet genoeg vrijheidsgraden voor de goodness-of-fit test.

```{r model-fit-ds-binned}
par(mfrow = c(1, 2))

# Uniform model
plot(dsmodelunif1_binned)
plot(dsmodelunif1_binned, pdf = TRUE, 
     main = paste0("dsmodelunif1_binned - ", "AIC: ", 
                   as.character(round(summary(dsmodelunif1_binned)$ds$aic, digits = 2))
                   )
     )

# Half-normal model
plot(dsmodelhn1_binned)
plot(dsmodelhn1_binned, pdf = TRUE, 
     main = paste0("dsmodelhn1_binned - ", "AIC: ", 
                   as.character(round(summary(dsmodelhn1_binned)$ds$aic, digits = 2))
                   )
     )

# Hazard-ratio model
plot(dsmodelhr1_binned)
plot(dsmodelhr1_binned, pdf = TRUE, 
     main = paste0("dsmodelhr1_binned - ", "AIC: ", 
                   as.character(round(summary(dsmodelhr1_binned)$ds$aic, digits = 2))
                   )
     )

par(mfrow = c(1, 1))
```

Op basis van model fit kiezen we opnieuw voor model 7 met de Hazard-rate functie en zonder covariaten. Dit model geeft de volgende detectiekans die gelijkaardig is als voordien:

```{r final-model-summary-ds-binned}
summary_hr1_binned <- summary(dsmodelhr1_binned)
summary_hr1_binned$ds$coeff$key.scale %>%
  kable(digits = 2)
```

We vergelijken de schattingen tussen het continu model en het laatste model met categorische afstanden.

```{r comparison-continuous-binned}
# Create summary table
summary_results_binned <- bind_rows(
  summary_hr1_binned$dht$clusters$D %>%
    mutate(variable = "density",
           type = "clusters"),
  summary_hr1_binned$dht$clusters$N %>%
    mutate(variable = "abundance",
           type = "clusters"),
  summary_hr1_binned$dht$individuals$D %>%
    mutate(variable = "density",
           type = "individuals"),
  summary_hr1_binned$dht$individuals$N %>%
    mutate(variable = "abundance",
           type = "individuals")
  ) %>%
  as_tibble() %>%
  separate(Label, c("regio", "periode_in_jaar"), sep = " - ") %>%
  filter(!is.na(periode_in_jaar))

# Plot continuous model
dist_model2 <- summary_results %>%
  filter(type == "individuals", variable == "abundance") %>%
  full_join(plots_per_regio, by = "regio") %>%
  mutate(Estimate = Estimate / n_plots,
         lcl = lcl / n_plots,
         ucl = ucl / n_plots) %>%
  ggplot(aes(x = regio, y = Estimate)) + 
  geom_point(aes(colour = periode_in_jaar), size = 4, 
             position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = lcl, ymax = ucl, colour = periode_in_jaar), 
                width = 0.25, position = position_dodge(width = 0.5)) + 
  scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
       name = "Aantal broedparen Gele kwikstaart per 100 ha"), limits = c(0, 2.5)) +
  labs(x = "", y = "", title = "Distance sampling continuous") +
  theme(legend.position = "bottom")

# Plot binned model
dist_model_binned <- summary_results_binned %>%
  filter(type == "individuals", variable == "abundance") %>%
  full_join(plots_per_regio, by = "regio") %>%
  mutate(Estimate = Estimate / n_plots,
         lcl = lcl / n_plots,
         ucl = ucl / n_plots) %>%
  ggplot(aes(x = regio, y = Estimate)) + 
  geom_point(aes(colour = periode_in_jaar), size = 4, 
             position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = lcl, ymax = ucl, colour = periode_in_jaar), 
                width = 0.25, position = position_dodge(width = 0.5)) + 
  scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
       name = "Aantal broedparen Gele kwikstaart per 100 ha"), limits = c(0, 2.5)) +
  labs(x = "", y = "", title = "Distance sampling binned") +
  theme(legend.position = "bottom")

# Plot next to each other
grid.arrange(dist_model2, dist_model_binned, ncol = 2)
```

Er is bijna geen verschil wanneer de afstanden per 100 m worden gegroepeerd.


### unmarked package

**Op verkenning**

In **Distance** deden we aan zgn. Conventional distance sampling (CDS) waarbij de afstanden werden gebundeld voor alle ruimtelijke locaties (i.c. plots) om de parameter(s) van de detectiefunctie te schatten, bijvoorbeeld \sigma voor de half-normaale functie. Dit wordt gebruikt om een schatting van de dichtheid te verkrijgen, en vervolgens wordt de variantie gebaseerd op de variantie van de "encounter rate", die wel enige informatie uit de plots gebruikt. Bij CDS wordt er ook uitgegaan dat dieren uniform worden verdeeld met betrekking tot transecten/telpunten en vereisen dus gerandomiseerde plaatsing van transecten/punten tijdens het steekproefdesign. Hierbij worden factoren die de abundantie tussen plots beïnvloeden verwaarloosd. \textcolour{red}{Dit klopt niet helemaal denk ik want we hebben wel enkele covariaten meegegeven in **Distance**. Het precieze onderscheid moet nog verder bekeken worden in de literatuur, maar het volgende is wel degelijk een andere techniek dan eerder gebruikt.} In de **unmarked** package kunnen we het zgn. Hierarchical distance sampling (HDS) toepassen. Dit zijn parametrisch modellen om variatie in abundantie tussen plots te beschrijven. In plaats van gegevens te bundelen als bij CDS, biedt HDS een expliciet model voor de variatie van de lokale populatiegrootte $N_s$ (de abundantie voor plot $s$). Door een model voor deze latente variabele specificeren, kunnen we dan expliciete modellen bouwen voor distance sampling data die verantwoordelijk zijn voor variatie in abundatie (of lokale dichtheid) tussen steekproefeenheden (plots), waardoor inferentie over factoren die ruimtelijke invloed hebben op variatie in abundatie wordt vergemakkelijkt alsook expliciete spatiale predicties over abundantie.

https://cran.r-project.org/web/packages/unmarked/vignettes/distsamp.html
https://www.rdocumentation.org/packages/unmarked/versions/1.2.5/topics/gdistsamp
https://rstudio-pubs-static.s3.amazonaws.com/221408_23c61679859e48e6bae0b9c5c2e48a92.html



### STAN

**Op verkenning**




## Opdelen in territoria

**Op verkenning**

Het aantal koppels wordt bepaald o.b.v.:

1. Uitsluitende waarnemingen  
Waarnemingen tijdens éénzelfde telling worden met volledige zekerheid als verschillende dieren beschouwd. Wij beschouwen vier telrondes.

2. Clustering op basis van fusieafstand  
Waarnemingen gedurende verschillende tellingen maar binnen een bepaalde geografische afstand van elkaar (= fusieafstand) worden geclusterd. We gaan er dan van uit dat dit hetzelfde dier was.

Deze strategie werkt enkel voor honkvaste soorten! Bovendien is de keuze van de fusieafstand belangrijk. Deze kan gebaseerd worden op basis van de data en/of literatuur. De volgende figuur geeft de afstanden weer tussen verschillende koppels binnen dezelfde telling (dus zelfde plot in zelfde telperiode). Dit kan echter een onderschatting geven aangezien onze tellingen zich tot cirkels met straal 300 m beperken. We weten niet of individuen op afstand > 600 m dezelfde zijn. Bovendien kunnen plots overlappen of < 600 m van elkaar verwijderd zijn. We verwachten dat dit echter in dit geval geen grote verschillen zal meebrengen voor deze exploratieve figuur. 

```{r broed-afstanden}
# Selecteer tellingen van Gele kwikstaart in 2022 in de twee regios
# met broedcode > 0 en binnen telrondes, we behouden de geometrie
gele_kwik_2022_territoria <- mas_clean %>%
  filter(naam == "Gele Kwikstaart", jaar == 2022, 
         !is.na(periode_in_jaar), wrntype > 0L) %>%  
  inner_join(design2022, by = "plotnaam") # Moeren en Leemstreek

# Selecteer coördinaten van broedkoppels waarvan er > 1 per telling
# (zelfde plot zelfde telperiode) werden gezien
broedkoppels <- gele_kwik_2022_territoria %>% 
  group_by(plotnaam, periode_in_jaar) %>%
  mutate(group_id = cur_group_id()) %>% 
  expand(nesting(group_id), nesting(group_id2 = group_id)) %>%
  filter(st_geometry_type(geom) == "MULTIPOINT") %>%
  st_cast(to = "POINT")

# Bereken paarsgewijze afstanden van broedkoppels per telling 
# (zelfde plot zelfde telperiode)
dst <- c()
for (group in broedkoppels$group_id) {
  df <- broedkoppels %>% filter(group_id == group)
  dst <- c(dst, st_distance(df))
}

# Functie om de modus te berekenen
fun.mode <- function(x){as.numeric(names(sort(-table(x)))[1])}

# Visualiseer in histogram (filter 0 m eruit)
plot_dist_terr <- dst %>% as_tibble() %>% 
  filter(value != 0) %>%
  ggplot() +
    geom_histogram(aes(x = value, y = ..density..), fill = "yellow", colour = "black", 
                   binwidth = 5, alpha = 0.5) +
    labs(x = "Kleinste afstand tot een ander koppel in dezelfde telling (m)") +
    geom_vline(xintercept = mean(dst[dst != 0]), colour = "darkgreen", size = 1.2) + 
    geom_vline(xintercept = quantile(dst[dst != 0], probs = c(0.25, 0.5, 0.75)), 
               colour = "darkblue", size = 1.2) +
    geom_vline(xintercept = fun.mode(dst[dst != 0]), colour = "darkred", size = 1.2) +
    geom_density(aes(x = value, y = ..density..), size = 1)
plot_dist_terr
```

Rood: modus. Blauw: Q1-Q3. Groen: gemiddelde.

We zullen er echter initieel voor kiezen om diameter van de telcirkel (600 m) als fusieafstand te nemen. We vermoeden dat dit een iets lager aantal koppels zal opleveren dan de maxima te nemen over de telperiodes indien de telcirkels overlappen of op minder dan 600 m verwijderd zijn van elkaar. Bovendien lijkt het een elegante manier om de territoriastrategie toe te passen op ons design.

**Data voorbereiden**

We hebben voor elke waarneming hun `x`- en `y`-coördinaten nodig in een geprojecteerd coördinatensysteem. `survey` is een geheel getal id voor elke telling. Een survey is dus een unieke combinatie van een plot en een telperiode. `status` is een geheel getal dat de broedcode aangeeft. Een hogere waarde veronderstelt meer zekerheid over een broedgeval. `id` is een unieke id voor iedere observatie

```{r data-prep-territoria}
# Voorbereiden dataframe
df_territoria <- gele_kwik_2022_territoria %>% 
  st_drop_geometry() %>%
  group_by(plotnaam, periode_in_jaar) %>%
  mutate(survey = cur_group_id(),
         status = as.integer(wrntype)) %>%
  ungroup() %>%
  rename(x = x_coord, y = y_coord) %>%
  select(oid, survey, status, x, y, aantal)

# Dupliceer rijen volgens aantal (elke rij is 1 individu)
df_territoria <- 
  tibble(
    df_territoria[rep(seq_len(dim(df_territoria)[1]), 
                  df_territoria$aantal), , 
                  drop = FALSE], 
    row.names = NULL
  )

# Gedupliceerde rijen hebben zelfde oid --> nieuw id maken voor elke waarneming
df_territoria <- df_territoria %>% mutate(id = row_number())
```

Zodra we een dataframe met de waarnemingen hebben, maken we verbinding met een SQLite-database en importeren de waarnemingen. Deze kent elke waarneming toe aan een eigen cluster.

```{r SQLite-territoria}
set.seed(20221103)

conn <- connect_db()
import_observations(observations = df_territoria, conn = conn, max_dist = 600)
```

Vervolgens moeten we de afstandsmatrix berekenen. Dit is niet de volledige afstandsmatrix. We laten alle irrelevante afstanden weg, b.v. tussen waarnemingen van dezelfde telling of met een afstand groter dan tweemaal de maximale clusterafstand.

```{r distmatrix-territoria}
distance_matrix(conn = conn, max_dist = 600)
```

**Clusteren met territoria**

Nu kunnen we beginnen met het clusteren. De clustering houdt rekening met alle waarnemingen met een broedcode hoger dan of gelijk aan de ingestelde broedcode. Herhaal de clustering voor elk broedcodeniveau. Merk op dat het overslaan van niveaus impliceert dat we ze combineren met het lagere niveau.

```{r cluster-territoria}
# Broedcodes
broedcodes <- sort(unique(df_territoria$status))

# Cluster van meest zekere broedcode naar minder zeker
result <- vector(mode = "list", length = length(broedcodes))
for (broedcode in rev(broedcodes)) {
  print(paste0("Clusteren broedcode ", broedcode))
  cluster_observation(conn = conn, status = broedcode, max_dist = 600)
  result[[broedcode]] <- get_cluster(conn = conn)
}
dbDisconnect(conn = conn)

# voeg clusternummer toe aan de dataset
df_territoria$cluster <- result[[1]]$observations$cluster
```

**Resultaten en visualisatie**

In totaal hadden we `r nrow(result[[1]]$observations)` observaties (waarneming van een bepaald individu in een plot in een bepaalde telperiode). Nu hebben we `r nrow(result[[1]]$cluster)` clusters (= broedparen).

```{r visualisatie-territoria}
territoria_per_plot <- df_territoria %>% 
  
  # Join om regio's te krijgen
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(cluster, regio) %>%
  
  # Voeg aantal plots per regio toe en bereken aantal clusters per plots
  full_join(plots_per_regio, by = "regio") %>%
  group_by(regio, n_plots) %>%
  summarise(broedparen = n_distinct(cluster), .groups = "drop") %>%
  mutate(Estimate = broedparen / n_plots,
         categorie = "territoria")
  
# Visualiseer
territoria_per_plot %>% 
  ggplot(aes(x = regio, y = Estimate)) + 
    geom_bar(aes(fill = regio), stat = "identity") + 
    scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
         name = "Aantal broedparen Gele kwikstaart per 100 ha")) +
    labs(x = "", y = "Aantal broedparen Gele kwikstaart per plot",
         title = "Aantal territoria") +
    theme(legend.position = "")
```

We vergelijken met de vorige resultaten. Ook berekenen we het relatief aantal broedparen op basis van het gemiddeld en maximum aantal per plot over de telperiodes. Hierbij is ook met absensies rekening gehouden (maakt voor maximum niet uit).

```{r comparison-territoria, fig.height=10}
plot_terr <- gele_kwik_2022 %>%
  st_drop_geometry() %>%
  
  # Bepaal voor elke plot het gemiddeld aantal individuen en maximum over
  # de telperiodes
  group_by(plotnaam, periode_in_jaar) %>%
  summarise(totaal = sum(aantal), .groups = "drop_last") %>%
  summarise(gemiddelde = mean(totaal),
            maximum = max(totaal),
            .groups = "drop") %>%
  
  # Join om regio's te krijgen, bereken dan het totaal aantal individuen over 
  # alle plots (som)
  inner_join(design2022, by = "plotnaam") %>%
  select(plotnaam, gemiddelde, maximum, regio) %>%
  group_by(regio) %>%
  summarise(tot_gemiddelde = sum(gemiddelde),
            tot_max = sum(maximum)) %>% 
  
  # Deel door aantal plots om aantal broedkoppels per plot te krijgen
  full_join(plots_per_regio, by = "regio") %>%
  mutate(tot_gemiddelde_plots = tot_gemiddelde / n_plots,
         tot_max_plots = tot_max / n_plots) %>%
  pivot_longer(cols = c("tot_gemiddelde_plots", "tot_max_plots"), 
               names_to = "categorie", values_to = "Estimate") %>%
  
  # Voeg territoria data toe
  select(regio, Estimate, categorie) %>%
  rbind(territoria_per_plot[, -c(2, 3)]) %>%
  
  # Visualiseer
  ggplot(aes(x = regio, y = Estimate)) + 
    geom_bar(aes(fill = regio), stat = "identity") + 
    scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
         name = "Aantal broedparen Gele kwikstaart per 100 ha")) +
    labs(x = "", y = "Aantal broedparen Gele kwikstaart per plot") +
    theme(legend.position = "") +
    facet_wrap(~categorie, labeller = labeller(
      categorie = c("tot_gemiddelde_plots" = "Gemiddeld aantal broedparen per plot",
                    "tot_max_plots" = "Maximum aantal broedparen per plot",
                    "territoria" = "Aantal territoria")))

grid.arrange(GLMM_model, dist_model, plot_terr, 
             layout_matrix = rbind(c(1, 2), c(3)))
```

**Discussie**

Dit is toch iets lager aantal dan verwacht (vergelijk met maximum). Vanwaar komen de eerste drie clusters? Deze clusters vormen steeds binnen een plot (zoals verwacht want als fusieafstand namen we de diameter van de telcirkel). Telkens werd een individu gezien in verschillende telkperiodes dus deze zijn geclusterd.

```{r table-territoria-clusters}
df_territoria %>%
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(oid, cluster, plotnaam, periode_in_jaar, regio) %>%
  filter(cluster %in% sort(unique(df_territoria$cluster))[1:3]) %>%
  arrange(cluster, plotnaam, periode_in_jaar) %>%
  kable()
```

Hoeveel territoria in eerste drie plots? In DM_1037.1 werd telkens 1 individu gezien in elke telperiode. Omdat het binnen de fusieafstand is worden deze waarnemingen geclusterd. In plots DM_1012.6 en DM_1024.10 werden in telperiode R2 twee individuen gezien waardoor er twee clusters zijn. Waarnemingen van andere telperiodes worden geclusterd met het eerste individu.

```{r table-territoria-plots}
df_territoria %>%
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(oid, cluster, plotnaam, periode_in_jaar, regio) %>%
  filter(plotnaam %in% sort(unique(gele_kwik_2022_territoria$plotnaam))[1:3]) %>%
  arrange(cluster, plotnaam, periode_in_jaar) %>%
  kable()
```

Op basis van deze gegevens zouden we een gelijkaardig aantal als bij de maxima verwachten. De analyses zijn wel verlopen zoals verwacht. Zijn er telcirkels die overlappen of die dicht bij elkaar liggen? Met andere woorden, zijn er clusters die in verschillende plots zijn gezien? De twee waarnemingen in cluster 11 bevinden zich in plots DM_222.6 en VL0070 op 488 m van elkaar, maar werden wel door dezelfde waarnemer (JJNN16) gezien op dezelfde dag (2022-06-02). Kunnen we er dan toch van uit gaan dat dit twee verschillende individuen zijn? Nee want niet op zelfde moment (telling) gezien. We zullen dus de cluster surveys niet minder strikt nemen volgens datum en waarnemer in plaats van plot en telperiode. 

```{r overlap-plots}
# Vind clusters met meerdere plots
multi_clust <- df_territoria %>%
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(oid, cluster, plotnaam, regio, periode_in_jaar) %>%
  
  # Aantal plots per cluster
  group_by(cluster) %>%
  summarise(n_plots = n_distinct(plotnaam)) %>%
  
  # Clusters met meer dan 1 plot
  filter(n_plots > 1) %>%
  pull(cluster)

# Tabel
df_territoria %>%
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(oid, cluster, plotnaam, periode_in_jaar, regio) %>%
  filter(cluster %in% multi_clust) %>%
  arrange(regio, cluster, plotnaam, periode_in_jaar) %>%
  kable()
```

Er is dus toch vrij veel overlap van plots (binnen 600 m). Dat verklaart waarom het aantal territoria iets lager is dan het aantal op basis van maxima per plot over de telperiodes. We kozen voor 600 m op basis van ons studiedesign, nl. de diameter van de telcirkel. Omdat er overlap is tussen plots op deze afstand krijgt deze arbitraire afstand nu plots een biologische mening (territoriumafstand Gele kwikstaart op 600 m, logisch?). Dat was niet de bedoeling. Wat we wel kunnen doen is een kleinere fusieafstand nemen met biologische betekenis.

**Kleinere fusieafstand**

```{r pieken-scenario2}
# Extract pieken
hist_piek <- ggplot_build(plot_dist_terr)$data[[1]] %>% 
  filter(y == max(y)) %>% 
  pull(x)
dens_piek <- ggplot_build(plot_dist_terr)$data[[5]] %>% 
  filter(y == max(y)) %>% 
  pull(x)
```

De top van de densiteitscurve van de koppelafstanden lag op `r round(dens_piek, digits = 2)` m, de top van de histogram op `r hist_piek` m, de mediaan op `r round(median(dst[dst != 0]), digits = 2)` m en het gemiddelde op `r round(mean(dst[dst != 0]), digits = 2)`. Om conservatief te blijven gaan we hier verder met het gemiddelde.

```{r territoria-scenario2}
# Set-up
set.seed(20221104)
fusie_dist <- mean(dst[dst != 0])

# Connect SQLite database en importeer observaties
conn2 <- connect_db()
import_observations(observations = df_territoria, conn = conn2, max_dist = fusie_dist)

# Bereken distance matrix
distance_matrix(conn = conn2, max_dist = fusie_dist)

# Cluster van meest zekere broedcode naar minder zeker
result2 <- vector(mode = "list", length = length(broedcodes))
for (broedcode in rev(broedcodes)) {
  print(paste0("Clusteren broedcode ", broedcode))
  cluster_observation(conn = conn2, status = broedcode, max_dist = fusie_dist)
  result2[[broedcode]] <- get_cluster(conn = conn2)
}
dbDisconnect(conn = conn2)

# voeg clusternummer toe aan de dataset
df_territoria2 <- df_territoria
df_territoria2$cluster <- result2[[1]]$observations$cluster
```

Met de grotere fusieafstand van 600m hadden we `r nrow(result[[1]]$cluster)` clusters (= broedparen), nu hebben we `r nrow(result2[[1]]$cluster)` clusters.

```{r comparison-territoria-scenario2, fig.height=10}
territoria_per_plot2 <- df_territoria2 %>% 
  
  # Join om regio's te krijgen
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(cluster, regio) %>%
  
  # Voeg aantal plots per regio toe en bereken aantal clusters per plots
  full_join(plots_per_regio, by = "regio") %>%
  group_by(regio, n_plots) %>%
  summarise(broedparen = n_distinct(cluster), .groups = "drop") %>%
  mutate(Estimate = broedparen / n_plots,
         categorie = "territoria")

plot_terr2 <- gele_kwik_2022 %>%
  st_drop_geometry() %>%
  
  # Bepaal voor elke plot het gemiddeld aantal individuen en maximum over
  # de telperiodes
  group_by(plotnaam, periode_in_jaar) %>%
  summarise(totaal = sum(aantal), .groups = "drop_last") %>%
  summarise(gemiddelde = mean(totaal),
            maximum = max(totaal),
            .groups = "drop") %>%
  
  # Join om regio's te krijgen, bereken dan het totaal aantal individuen over 
  # alle plots (som)
  inner_join(design2022, by = "plotnaam") %>%
  select(plotnaam, gemiddelde, maximum, regio) %>%
  group_by(regio) %>%
  summarise(tot_gemiddelde = sum(gemiddelde),
            tot_max = sum(maximum)) %>% 
  
  # Deel door aantal plots om aantal broedkoppels per plot te krijgen
  full_join(plots_per_regio, by = "regio") %>%
  mutate(tot_gemiddelde_plots = tot_gemiddelde / n_plots,
         tot_max_plots = tot_max / n_plots) %>%
  pivot_longer(cols = c("tot_gemiddelde_plots", "tot_max_plots"), 
               names_to = "categorie", values_to = "Estimate") %>%
  
  # Voeg territoria data toe
  select(regio, Estimate, categorie) %>%
  rbind(territoria_per_plot2[, -c(2, 3)]) %>%
  
  # Visualiseer
  ggplot(aes(x = regio, y = Estimate)) + 
    geom_bar(aes(fill = regio), stat = "identity") + 
    scale_y_continuous(sec.axis = sec_axis( ~. / cirkelopp * 1e6, 
         name = "Aantal broedparen Gele kwikstaart per 100 ha")) +
    labs(x = "", y = "Aantal broedparen Gele kwikstaart per plot") +
    theme(legend.position = "") +
    facet_wrap(~categorie, labeller = labeller(
      categorie = c("tot_gemiddelde_plots" = "Gemiddeld aantal broedparen per plot",
                    "tot_max_plots" = "Maximum aantal broedparen per plot",
                    "territoria" = "Aantal territoria")))

grid.arrange(GLMM_model, dist_model, plot_terr2, 
             layout_matrix = rbind(c(1, 2), c(3)))
```

Nu zien we dat de territoria hoger zijn dan het maximum. Dat komt omdat nu ook binnen plots clusters worden gevormd indien waarnemingen ver genoeg uit elkaar liggen en niet in dezelfde telperiode zijn gedaan.  

Is er ook nog steeds overlap in plots?

```{r overlap-plots-scenario2}
# Vind clusters met meerdere plots
multi_clust2 <- df_territoria2 %>%
  inner_join(gele_kwik_2022_territoria, by = "oid") %>%
  select(oid, cluster, plotnaam, regio, periode_in_jaar) %>%
  
  # Aantal plots per cluster
  group_by(cluster) %>%
  summarise(n_plots = n_distinct(plotnaam)) %>%
  
  # Clusters met meer dan 1 plot
  filter(n_plots > 1) %>%
  pull(cluster)

length(multi_clust2)
```

Geen overlap meer.
