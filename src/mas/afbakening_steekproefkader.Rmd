---
title: "MAS afbakening steekproefkader"
author: "Hans Van Calster"
date: "`r Sys.Date()`"
bibliography: mas.json
output:
  bookdown::html_document2:
    code_folding: hide
    toc: true
    toc_float: true
    toc_collapsed: true
---

```{r setup, include=FALSE}
library(knitr)
library(here)
opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE)
opts_knit$set(root.dir = here::here())
library(tidyverse)
library(sf)
library(nngeo)
library(mapview)
library(readxl)
library(gt)
library(httr)
library(osmextract)
library(terra)
library(exactextractr)
library(arrow)
source(here("R", "wfs_wcs.R"))
source(here("R", "read_agri_use_parcels.R"))
source(here("R", "utils.R"))
source(here("R", "landuse_maps.R"))
source(here("R", "abv.R"))
source(here("R", "agro_environment_schemes.R"))
source(here("R", "geocomputations.R"))
```

# Afbakening steekproefkader

## Perimeter bepalen

= intersectie landbouwstreek België met contour Vlaanderen en overlappend met prioritaire gebieden voor akkervogels

```{r warning=FALSE}
landbouwstreken <- read_sf(
  here("data", "landbouwstreken", "Lbstrbel.shp")) %>%
  st_transform(crs = 31370) %>%
  select(NAAM)

vlaanderen <- get_feature_wfs(
  wfs = "https://eservices.minfin.fgov.be/arcgis/services/R2C/Regions/MapServer/WFSServer",
  layername = "regions",
  crs = "EPSG:31370",
  filter = "<Filter><PropertyIsEqualTo><PropertyName>regions:NameDUT</PropertyName><Literal>'Vlaams Gewest'</Literal></PropertyIsEqualTo></Filter>") %>%
  select(NameDUT)

westkustpolder <- get_feature_wfs(
  wfs = "https://geoservices.informatievlaanderen.be/overdrachtdiensten/Polders/wfs",
  version = "1.1.0",
  layername = "Polders:Polder",
  crs = "urn:x-ogc:def:crs:EPSG:31370",
  ) %>%
  st_cast(to = "GEOMETRYCOLLECTION") %>%
  mutate(id = seq_len(nrow(.))) %>%
  st_collection_extract("POLYGON") %>%
  aggregate(list(.$id), first, do_union = FALSE) %>%
  select(NAAMPOL) %>%
  filter(NAAMPOL == "Westkustpolder") %>%
  as_tibble %>%
  st_as_sf(crs = 31370)

plan_kiekendief_perimeter <- read_sf(
  here("data", "mas", "Grauwe_kiekendief_VLM3.kml")
) %>%
  select(-Description) %>%
  st_simplify() %>%
  st_transform(crs = 31370) %>%
  mutate(regio = case_when(
    Name == "moeren" ~ "Moeren",
    Name %in% c(
      "akkerplateau omgeving Gingelom",
      "akkerplateaus Heers-Riemst",
      "landbouwgebieden ruime omgeving Hoegaarden"
    ) ~ "Leemstreek",
    TRUE ~ "Limburg"
  )) %>%
  filter(regio != "Limburg")

leemstreek <- landbouwstreken %>%
  filter(NAAM == "Leemstreek") %>%
  st_intersection(vlaanderen)

polders <- landbouwstreken %>%
  filter(NAAM == "Polders") %>%
  st_intersection(vlaanderen)

legend <- read_csv2(
      "data/landgebruik/legende_landgebruik.csv",
      col_types = cols(
        bron = col_character(),
        bestand_id = col_character(),
        value = col_double(),
        label = col_character(),
        kleur = col_character()
      ))
```

```{r map-1, out.width="100%"}
mapview(leemstreek) +
  mapview(polders) +
  mapview(plan_kiekendief_perimeter)
```

```{r}
leemstreek_pk <- leemstreek %>%
  st_cast("POLYGON") %>%
  st_filter(plan_kiekendief_perimeter)

polders_pk <- polders %>%
  st_cast("POLYGON") %>%
  st_filter(plan_kiekendief_perimeter)
  
```

```{r map-2, out.width="100%"}
mapview(leemstreek_pk, color = "brown", col.regions = "brown") +
  mapview(polders_pk) +
  mapview(plan_kiekendief_perimeter, zcol = "regio")
```

We gaan verder met enkel de Leemstreek.

## Exclusie van bepaalde landgebruiken

- https://wiki.openstreetmap.org/wiki/Key:leisure
    - park
- https://wiki.openstreetmap.org/wiki/Key:landuse
    - residential
    - military
    - industrial
    - cemetery

```{r leemstreek-exclusie}
# Define the vectortranslate options
landuse_exclusie_vectortranslate = c(
  "-t_srs", "EPSG:31370",
  "-select", "landuse",
  "-where", "landuse IN ('residential', 'military', 'industrial', 'cemetery') OR 
  leisure IN ('park')",
  "-nlt", "PROMOTE_TO_MULTI"
)

leemstreek_exclusie <- oe_get(
  place = leemstreek_pk,
  layer = "multipolygons",
  vectortranslate_options = landuse_exclusie_vectortranslate,
  boundary = leemstreek_pk,
  boundary_type = "clipsrc",
  download_directory = here("data", "osmdata"))

leemstreek_exclusie <- leemstreek_exclusie %>%
  st_cast("GEOMETRYCOLLECTION") %>%
  mutate(id = seq_len(nrow(.))) %>%
  st_collection_extract("POLYGON") %>%
  aggregate(list(.$id), first, do_union = FALSE) %>%
  select(-id, -Group.1) %>%
  as_tibble %>%
  st_as_sf()
```


Verder vereenvoudigen van de polygonenkaart door:

- alle polygonen samen te voegen tot 1 multipolygon (union)
- bufferen met straal 20 m
- overtollige vertices verwijderen met tolerantie 10 m
- alle gaten (polygon holes) verwijderen


```{r exclusie-simplified}
leemstreek_exclusie %>%
  st_union() %>%
  st_buffer(dist = 20) %>%
  st_simplify(dTolerance = 10) %>%
  st_remove_holes() -> leemstreek_exclusie_simplified
```

```{r map-exclusies, out.width="100%"}
complex <- leemstreek_exclusie %>%
  mapview()
eenvoudig <- leemstreek_exclusie_simplified %>%
  mapview()

leafsync::sync(complex, eenvoudig)
```

## Bepalen geldige plaatsen waar telling kan uitgevoerd worden

Extractie uit Openstreetmap:

- https://wiki.openstreetmap.org/wiki/Key:highway
    - track
    - footway
    - path
    - cycleway
    - bridleway
    - tertiary
    - tertiary_link
    - unclassified

```{r leemstreek-paden}
# Define the vectortranslate options
my_vectortranslate = c(
  "-t_srs", "EPSG:31370",
  "-select", "highway",
  "-where", "highway IN ('track', 'footway', 'path', 'cycleway',
  'bridleway', 'tertiary', 'tertiary_link', 'unclassified')",
  "-nlt", "PROMOTE_TO_MULTI"
)

# Read-in data
leemstreek_paden <- oe_get(
  place = leemstreek_pk,
  vectortranslate_options = my_vectortranslate,
  boundary = leemstreek_pk,
  boundary_type = "spat",
  download_directory = here("data", "osmdata"))
```

Verwijderen van paden die overlappen met exclusiekaart.

```{r verwijder-paden}
leemstreek_paden %>%
  st_difference(
    leemstreek_exclusie_simplified) %>%
  st_intersection(
    leemstreek_pk %>% st_buffer(dist = 10)) -> leemstreek_paden_kader
```


Verwijderen van overlappende paden.

```{r verwijder-overlappende-paden}
leemstreek_paden_kader %>%
  st_filter(y = leemstreek_paden_kader,
            .predicate =  st_relate,
            pattern = "1FFF0FFF2") -> leemstreek_paden_kader
```


```{r map-5, out.width="100%"}
mapview(leemstreek_exclusie_simplified) +
  mapview(leemstreek_paden_kader)
```

Overzicht totale lengte per categorie:

```{r lengte-paden}
leemstreek_paden_kader %>%
  group_by(highway) %>%
  summarise() %>%
  mutate(lengte_km = as.numeric(st_length(.)) / 1e3) %>%
  st_drop_geometry() %>%
  kable(digits = 1)
```

## Punten langs de paden

- Op regelmatige afstanden van 50 m

```{r leemstreek-punten}
lpk <- leemstreek_paden_kader %>%
  st_cast("MULTILINESTRING") %>%
  st_cast("LINESTRING", warn = FALSE)

interpoint_distance <- 50

st_drop_geometry(lpk) %>%
  bind_cols(
    lpk %>%
      st_line_sample(
        density = units::set_units(1000 / interpoint_distance, 1/km),
        type = "regular") %>%
      st_as_sf() %>%
      rename(geometry = x)
    ) %>%
  st_as_sf() -> leemstreek_multipoint

leemstreek_multipoint %>%
  st_cast("POINT", warn = FALSE) %>%
  rownames_to_column(var = "pointid") -> leemstreek_point

# punten die alsnog te dicht bij elkaar liggen verwijderen

clusters <- leemstreek_point %>%
    st_buffer(dist = interpoint_distance / 2 - 5) %>%
    st_union() %>%
    st_cast("POLYGON")

groups_too_close <- st_intersects(
  leemstreek_point,
  clusters
)

leemstreek_point %>%
  bind_cols(groups = unlist(groups_too_close)) %>%
  group_by(groups) %>%
  slice_head(n = 1) %>%
  select(-groups) -> leemstreek_point
```

```{r eval=FALSE}
mapview(leemstreek_point)
```


```{r}
leemstreek_point %>%
  st_drop_geometry() %>%
  count(highway, name = "Aantal punten") %>%
  kable()
```


## Berekening van attributen in buffer met straal 300 m

Voor elke centroïde:

- BO oppervlaktes
- landgebruik oppervlaktes
- KLE oppervlaktes / lengtes
- kwantiel van de hoogteligging ter plaatse van de centroïde (om in te schatten of de centroïde laag, gemiddeld of hoog gelegen is in omgevend landschap)
- maat voor complexiteit van het landschap (=> OLA vs KLA)

### Landgebruik

VITO 2019 landgebruikskaart

```{r lum2019vito}
lum2019vito <- lum_read_from_vito() %>%
  terra::crop(y = ext(leemstreek_pk %>% st_buffer(dist = 300)))

write_results_lum2019vito <-
  here("data", "processed",
       "leemstreek_points_lumvito2019_b300.parquet")
```



```{r}
st_bbox.SpatRaster = function(obj, ...) {
    bb = as.vector(terra::ext(obj))[c(1,3,2,4)]
    names(bb) = c("xmin", "ymin", "xmax", "ymax")
    st_bbox(bb, crs = st_crs(obj))
}

st_crs.SpatRaster = function(x, ...) {
    st_crs(crs(x))
}
```


```{r landuse-vito-2019-extract, eval=!file.exists(write_results_lum2019vito)}

# enkele minuten geduld
points_lum2019 <- landusemetrics_grid_cell(
  grid_cell = leemstreek_point %>%
    st_buffer(dist = 300), 
  layer = lum2019vito,
  grid_group_by_col = "pointid")


write_parquet(points_lum2019,
              sink = write_results_lum2019vito)
```

```{r bo-file}
file_bo <- here("data", "processed", "bo2021_points_b300.parquet")
```


```{r bo-calc, eval=!file.exists(file_bo)}
bo2021 <- read_aes(year = 2021,
                    path = here("data", "bo_vlm"))

points_bo2021 <- landusemetrics_grid_cell(
  grid_cell = leemstreek_point %>%
    st_buffer(dist = 300),
  layer = bo2021 %>% st_transform(crs = 31370), 
  grid_group_by_col = "pointid", 
  layer_group_by_col = "SRT_OBJECT")

write_parquet(points_bo2021, file_bo)
```



## Exclusie telcirkels op basis van attributen

Nodig?

Criteria?

- oppervlakte-aandeel landbouw < x ha
- ...

```{r landuse-vito-2019-results, eval=file.exists(write_results_lum2019vito)}
points_lum2019 <- read_parquet(write_results_lum2019vito,
                               as_data_frame = FALSE)

legende_lumvito2019 <- legend %>%
              filter(bestand_id == "vito") %>%
              select(value, label, kleur)

points_ago <- points_lum2019 %>%
  left_join(legende_lumvito2019) %>%
  collect() %>%
  mutate(label2 = factor(label, 
                         levels = c("Akker", "Grasland", "Bos", "Struikgewas")),
         label2 = as.character(label2),
         label2 = ifelse(is.na(label2), "Overige", label2)) %>%
  group_by(pointid, label2) %>%
  summarise(freq = sum(freq), .groups = "drop") %>%
  pivot_wider(names_from = label2, values_from = freq, values_fill = 0) 

points_ago %>%
  ggtern::ggtern(aes(x = Akker, y = Grasland + Bos + Struikgewas,
                     z = Overige)) + 
  geom_point(alpha = 0.1,
             aes(colour = (Grasland + Bos + Struikgewas)^2 + Akker^2 > 0.5^2))
```


```{r}
leemstreek_point %>%
  left_join(points_ago,
            by = "pointid") %>%
  mutate(selectie = (Grasland + Bos + Struikgewas)^2 + Akker^2 > 0.5^2) %>%
  mapview(zcol = "selectie")
```


```{r eval=file.exists(file_bo)}
points_bo2021 <- read_parquet(file = file_bo)

points_bo2021 %>%
  ggplot() + 
  geom_histogram(aes(x = as.numeric(area_prop), fill = SRT_OBJECT))
```


## DTM

Opvragen van DTM op 20 m resolutie.
Dit is wellicht voldoende resolutie?
Hogere resolutie via WCS opvragen gaf error voor zo'n groot gebied - de DTM is origineel op 1 m resolutie, maar dat is wellicht niet nodig.

```{r leemstreek-dtm, eval=!file.exists(here("data", "dtm", "leemstreek_dtm.tif"))}
bbox <- round(st_bbox(leemstreek_pk))
bbox <- bbox[c("xmin", "xmax", "ymin", "ymax")]

leemstreek_dtm20 <- get_coverage_wcs(
  wcs = "dtm",
  bbox = bbox,
  layername = "EL.GridCoverage.DTM",
  resolution = 20)
```

```{r}
terra::plot(leemstreek_dtm20)
```

